package mei.basic

// This file is auto-generated from MEI RelaxNG schema.
// Do not edit this file manually.

/** data.ACCIDENTAL.WRITTEN
  */
type DataACCIDENTALWRITTEN = java.lang.String

/** data.ACCIDENTAL.WRITTEN.basic
  */
type DataACCIDENTALWRITTENBasic = java.lang.String

/** data.ACCIDENTAL.WRITTEN.extended
  */
type DataACCIDENTALWRITTENExtended = java.lang.String

/** data.ACCIDENTAL.aeu
  */
type DataACCIDENTALAeu = java.lang.String

/** data.ACCIDENTAL.persian
  */
type DataACCIDENTALPersian = java.lang.String

/** data.ACCIDENTAL.GESTURAL
  */
type DataACCIDENTALGESTURAL = java.lang.String

/** data.ACCIDENTAL.GESTURAL.basic
  */
type DataACCIDENTALGESTURALBasic = java.lang.String

/** data.ACCIDENTAL.GESTURAL.extended
  */
type DataACCIDENTALGESTURALExtended = java.lang.String

/** data.ARTICULATION
  */
type DataARTICULATION = java.lang.String

/** data.AUGMENTDOT
  */
type DataAUGMENTDOT = java.lang.String

/** data.BARRENDITION
  */
type DataBARRENDITION = java.lang.String

/** data.BEAT
  */
type DataBEAT = java.lang.String

/** data.BEATRPT.REND
  */
type DataBEATRPTREND = java.lang.String

/** data.BOOLEAN
  */
type DataBOOLEAN = java.lang.String

/** data.CLEFLINE
  */
type DataCLEFLINE = java.lang.String

/** data.CLEFSHAPE
  */
type DataCLEFSHAPE = java.lang.String

/** data.CLUSTER
  */
type DataCLUSTER = java.lang.String

/** data.COLORNAMES
  */
type DataCOLORNAMES = java.lang.String

/** data.COLORVALUES
  */
type DataCOLORVALUES = java.lang.String

/** data.COLOR
  */
type DataCOLOR = java.lang.String

/** data.DEGREES
  */
type DataDEGREES = java.lang.String

/** data.DURATION
  */
type DataDURATION = java.lang.String

/** data.ENCLOSURE
  */
type DataENCLOSURE = java.lang.String

/** data.FINGER.FRET
  */
type DataFINGERFRET = java.lang.String

/** data.FONTFAMILY
  */
type DataFONTFAMILY = java.lang.String

/** data.FONTNAME
  */
type DataFONTNAME = java.lang.String

/** data.FONTSIZE
  */
type DataFONTSIZE = java.lang.String

/** data.FONTSIZENUMERIC
  */
type DataFONTSIZENUMERIC = java.lang.String

/** data.FONTSIZESCALE
  */
type DataFONTSIZESCALE = java.lang.String

/** data.FONTSIZETERM
  */
type DataFONTSIZETERM = java.lang.String

/** data.FONTSTYLE
  */
type DataFONTSTYLE = java.lang.String

/** data.FONTWEIGHT
  */
type DataFONTWEIGHT = java.lang.String

/** data.FRETNUMBER
  */
type DataFRETNUMBER = java.lang.String

/** data.GRACE
  */
type DataGRACE = java.lang.String

/** data.HEXNUM
  */
type DataHEXNUM = java.lang.String

/** data.HORIZONTALALIGNMENT
  */
type DataHORIZONTALALIGNMENT = java.lang.String

/** data.ISODATE
  */
type DataISODATE = java.lang.String

/** data.KEYFIFTHS
  */
type DataKEYFIFTHS = java.lang.String

/** data.LINEFORM
  */
type DataLINEFORM = java.lang.String

/** data.LINESTARTENDSYMBOL
  */
type DataLINESTARTENDSYMBOL = java.lang.String

/** data.LINEWIDTH
  */
type DataLINEWIDTH = java.lang.String

/** data.LINEWIDTHTERM
  */
type DataLINEWIDTHTERM = java.lang.String

/** data.MEASUREBEAT
  */
type DataMEASUREBEAT = java.lang.String

/** data.MEASUREMENTUNSIGNED
  */
type DataMEASUREMENTUNSIGNED = java.lang.String

/** data.MEASUREMENTSIGNED
  */
type DataMEASUREMENTSIGNED = java.lang.String

/** data.MEASUREMENTFONTUNSIGNED
  */
type DataMEASUREMENTFONTUNSIGNED = java.lang.String

/** data.MEASUREMENTFONTSIGNED
  */
type DataMEASUREMENTFONTSIGNED = java.lang.String

/** data.MEASUREMENTTYPOGRAPHYUNSIGNED
  */
type DataMEASUREMENTTYPOGRAPHYUNSIGNED = java.lang.String

/** data.MEASUREMENTTYPOGRAPHYSIGNED
  */
type DataMEASUREMENTTYPOGRAPHYSIGNED = java.lang.String

/** data.METERSIGN
  */
type DataMETERSIGN = java.lang.String

/** data.MIDICHANNEL
  */
type DataMIDICHANNEL = java.lang.String

/** data.MIDIBPM
  */
type DataMIDIBPM = java.lang.String

/** data.MIDIMSPB
  */
type DataMIDIMSPB = java.lang.String

/** data.MIDINAMES
  */
type DataMIDINAMES = java.lang.String

/** data.MIDIVALUE
  */
type DataMIDIVALUE = java.lang.String

/** data.MIDIVALUE_NAME
  */
type DataMIDIVALUENAME = java.lang.String

/** data.MIDIVALUE_PAN
  */
type DataMIDIVALUEPAN = java.lang.String

/** data.MIDIVALUE_PERCENT
  */
type DataMIDIVALUEPERCENT = java.lang.String

/** data.NCNAME
  */
type DataNCNAME = java.lang.String

/** data.OCTAVE
  */
type DataOCTAVE = java.lang.String

/** data.OCTAVE.DIS
  */
type DataOCTAVEDIS = java.lang.String

/** data.PEDALSTYLE
  */
type DataPEDALSTYLE = java.lang.String

/** data.PERCENT
  */
type DataPERCENT = java.lang.String

/** data.PERCENT.LIMITED
  */
type DataPERCENTLIMITED = java.lang.String

/** data.PERCENT.LIMITED.SIGNED
  */
type DataPERCENTLIMITEDSIGNED = java.lang.String

/** data.PGFUNC
  */
type DataPGFUNC = java.lang.String

/** data.PITCHNAME
  */
type DataPITCHNAME = java.lang.String

/** data.PITCHNAME.GESTURAL
  */
type DataPITCHNAMEGESTURAL = java.lang.String

/** data.STAFFREL
  */
type DataSTAFFREL = java.lang.String

/** data.STAFFREL.basic
  */
type DataSTAFFRELBasic = java.lang.String

/** data.STAFFREL.extended
  */
type DataSTAFFRELExtended = java.lang.String

/** data.STEMDIRECTION
  */
type DataSTEMDIRECTION = java.lang.String

/** data.STEMDIRECTION.basic
  */
type DataSTEMDIRECTIONBasic = java.lang.String

/** data.STEMDIRECTION.extended
  */
type DataSTEMDIRECTIONExtended = java.lang.String

/** data.STEMMODIFIER
  */
type DataSTEMMODIFIER = java.lang.String

/** data.STRINGNUMBER
  */
type DataSTRINGNUMBER = java.lang.String

/** data.TEMPERAMENT
  */
type DataTEMPERAMENT = java.lang.String

/** data.TEMPOVALUE
  */
type DataTEMPOVALUE = java.lang.String

/** data.TEXTRENDITIONLIST
  */
type DataTEXTRENDITIONLIST = java.lang.String

/** data.TEXTRENDITIONPAR
  */
type DataTEXTRENDITIONPAR = java.lang.String

/** data.TEXTRENDITION
  */
type DataTEXTRENDITION = java.lang.String

/** data.URI
  */
type DataURI = java.lang.String

/** data.VERTICALALIGNMENT
  */
type DataVERTICALALIGNMENT = java.lang.String

/** data.WORD
  */
type DataWORD = java.lang.String

/** data.DURATION.cmn
  */
type DataDURATIONCmn = java.lang.String

/** data.HARPPEDALPOSITION
  */
type DataHARPPEDALPOSITION = java.lang.String

/** macro.availabilityPart
  */
type MacroAvailabilityPart = java.lang.String

/** data.COURSENUMBER
  */
type DataCOURSENUMBER = java.lang.String

/** <arpeg>
  *
  * (arpeggiation) Indicates that the notes of a chord are to be performed successively rather than simultaneously, usually from lowest to highest. Sometimes called a "roll".
  */
case class Arpeg(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <arpeg> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <arpeg> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <arpeg> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <arpeg> -> att.arpeg.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <arpeg> -> att.arpeg.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <arpeg> -> att.arpeg.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <arpeg> -> att.arpeg.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <arpeg> -> att.arpeg.log -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Describes the direction in which an arpeggio is to be performed.
      *
      * <arpeg> -> att.arpeg.log -> att.arpeg.log.attribute.order -> @order
      */
    `@order`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <arpeg> -> att.arpeg.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <arpeg> -> att.arpeg.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <arpeg> -> att.arpeg.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <arpeg> -> att.arpeg.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <arpeg> -> att.arpeg.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <arpeg> -> att.arpeg.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Describes the style of a line.
      *
      * <arpeg> -> att.arpeg.vis -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <arpeg> -> att.arpeg.vis -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <arpeg> -> att.arpeg.vis -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** Contains the name of a font-family.
      *
      * <arpeg> -> att.arpeg.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <arpeg> -> att.arpeg.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <arpeg> -> att.arpeg.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <arpeg> -> att.arpeg.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <arpeg> -> att.arpeg.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <arpeg> -> att.arpeg.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <arpeg> -> att.arpeg.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <arpeg> -> att.arpeg.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <arpeg> -> att.arpeg.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Indicates if an arrowhead is to be drawn as part of the arpeggiation symbol.
      *
      * <arpeg> -> att.arpeg.vis -> att.arpeg.vis.attribute.arrow -> @arrow
      */
    `@arrow`: scala.Option[DataBOOLEAN] = scala.None,
    /** Symbol rendered at end of the line.
      *
      * <arpeg> -> att.arpeg.vis -> att.arpeg.vis.attribute.arrow.shape -> @arrow.shape
      */
    `@arrow.shape`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the arrow symbol.
      *
      * <arpeg> -> att.arpeg.vis -> att.arpeg.vis.attribute.arrow.size -> @arrow.size
      */
    `@arrow.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Captures the overall color of the arrow.
      *
      * <arpeg> -> att.arpeg.vis -> att.arpeg.vis.attribute.arrow.color -> @arrow.color
      */
    `@arrow.color`: scala.Option[DataCOLOR] = scala.None,
    /** Captures the fill color of the arrow if different from the line color.
      *
      * <arpeg> -> att.arpeg.vis -> att.arpeg.vis.attribute.arrow.fillcolor -> @arrow.fillcolor
      */
    `@arrow.fillcolor`: scala.Option[DataCOLOR] = scala.None,
)

/** <beam>
  *
  * A container for a series of explicitly beamed events that begins and ends entirely within a measure.
  */
case class Beam(
    /** <beam> -> model.eventLike.cmn -> bTrem -> <bTrem> (-> BTrem)
      * <beam> -> model.eventLike.cmn -> beam -> <beam> (-> Beam)
      * <beam> -> model.eventLike.cmn -> beatRpt -> <beatRpt> (-> BeatRpt)
      * <beam> -> model.eventLike -> chord -> <chord> (-> Chord)
      * <beam> -> model.eventLike -> clef -> <clef> (-> Clef)
      * <beam> -> model.eventLike -> clefGrp -> <clefGrp> (-> ClefGrp)
      * <beam> -> model.eventLike.cmn -> fTrem -> <fTrem> (-> FTrem)
      * <beam> -> model.eventLike.cmn -> graceGrp -> <graceGrp> (-> GraceGrp)
      * <beam> -> model.eventLike.cmn -> halfmRpt -> <halfmRpt> (-> HalfmRpt)
      * <beam> -> model.eventLike -> note -> <note> (-> Note)
      * <beam> -> model.eventLike -> rest -> <rest> (-> Rest)
      * <beam> -> model.eventLike -> space -> <space> (-> Space)
      * <beam> -> model.eventLike -> tabGrp -> <tabGrp> (-> TabGrp)
      * <beam> -> model.eventLike.cmn -> tuplet -> <tuplet> (-> Tuplet)
      */
    elements: scala.List[
      BTrem | Beam | BeatRpt | Chord | Clef | ClefGrp | FTrem | GraceGrp | HalfmRpt | Note | Rest | Space | TabGrp |
        Tuplet,
    ] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <beam> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <beam> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <beam> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <beam> -> att.beam.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <beam> -> att.beam.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <beam> -> att.beam.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** <beam> -> att.beam.vis -> att.cue -> att.cue.attribute.cue -> @cue
      */
    `@cue`: scala.Option[DataBOOLEAN] = scala.None,
)

/** <beatRpt>
  *
  * (beat repeat) An indication that material on a preceding beat should be repeated.
  */
case class BeatRpt(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <beatRpt> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <beatRpt> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <beatRpt> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <beatRpt> -> att.beatRpt.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <beatRpt> -> att.beatRpt.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Indicates the performed duration represented by the beatRpt symbol; expressed in time signature denominator units.
      *
      * <beatRpt> -> att.beatRpt.log -> att.beatRpt.log.attribute.beatdef -> @beatdef
      */
    `@beatdef`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <beatRpt> -> att.beatRpt.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Indicates whether to render a repeat symbol or the source material to which it refers. A value of 'true' renders the source material, while 'false' displays the repeat symbol.
      *
      * <beatRpt> -> att.beatRpt.vis -> att.expandable -> att.expandable.attribute.expand -> @expand
      */
    `@expand`: scala.Option[DataBOOLEAN] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <beatRpt> -> att.beatRpt.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <beatRpt> -> att.beatRpt.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <beatRpt> -> att.beatRpt.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <beatRpt> -> att.beatRpt.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Indicates the number of slashes required to render the appropriate beat repeat symbol. When a single beat consisting of a single note or chord is repeated, the repetition symbol is a single thick, slanting slash; therefore, the value 1 should be used. When the beat is divided into even notes, the following values should be used: 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4, 128ths=5. When the beat is comprised of mixed duration values, the default rendition is 2 slashes and 2 dots.
      *
      * <beatRpt> -> att.beatRpt.vis -> att.beatRpt.vis.attribute.slash -> @slash
      */
    `@slash`: DataBEATRPTREND,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <beatRpt> -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
)

/** <breath>
  *
  * (breath mark) An indication of a point at which the performer on an instrument requiring breath (including the voice) may breathe.
  */
case class Breath(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <breath> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <breath> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <breath> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <breath> -> att.breath.log -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <breath> -> att.breath.log -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <breath> -> att.breath.log -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <breath> -> att.breath.log -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <breath> -> att.breath.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <breath> -> att.breath.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <breath> -> att.breath.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <breath> -> att.breath.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <breath> -> att.breath.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <breath> -> att.breath.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <breath> -> att.breath.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <bTrem>
  *
  * (bowed tremolo) A rapid alternation on a single pitch or chord.
  */
case class BTrem(
    /** <bTrem> -> chord -> <chord> (-> Chord)
      * <bTrem> -> note -> <note> (-> Note)
      */
    elements: scala.List[Chord | Note] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <bTrem> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <bTrem> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <bTrem> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <bTrem> -> att.bTrem.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <bTrem> -> att.bTrem.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Records the number of augmentation dots required by a written dotted duration.
      *
      * <bTrem> -> att.bTrem.log -> att.augmentDots -> att.augmentDots.attribute.dots -> @dots
      */
    `@dots`: scala.Option[DataAUGMENTDOT] = scala.None,
    /** (duration) Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
      *
      * <bTrem> -> att.bTrem.log -> att.duration.log -> att.duration.log.attribute.dur -> @dur
      */
    `@dur`: scala.Option[DataDURATION] = scala.None,
    /** (number) Records a number or count accompanying a notational feature.
      *
      * <bTrem> -> att.bTrem.log -> att.numbered -> att.numbered.attribute.num -> @num
      */
    `@num`: scala.Option[java.lang.String] = scala.None,
    /** Describes the style of the tremolo.
      *
      * <bTrem> -> att.bTrem.log -> att.tremForm -> att.tremForm.attribute.form -> @form
      */
    `@form`: scala.Option[java.lang.String] = scala.None,
    /** (number placement) States where the tuplet number will be placed in relation to the note heads.
      *
      * <bTrem> -> att.bTrem.vis -> att.numberPlacement -> att.numberPlacement.attribute.num.place -> @num.place
      */
    `@num.place`: scala.Option[DataSTAFFRELBasic] = scala.None,
    /** Determines if the tuplet number is visible.
      *
      * <bTrem> -> att.bTrem.vis -> att.numberPlacement -> att.numberPlacement.attribute.num.visible -> @num.visible
      */
    `@num.visible`: scala.Option[DataBOOLEAN] = scala.None,
    /** The performed duration of an individual note in a measured tremolo.
      *
      * <bTrem> -> att.bTrem.ges -> att.tremMeasured -> att.tremMeasured.attribute.unitdur -> @unitdur
      */
    `@unitdur`: scala.Option[DataDURATIONCmn] = scala.None,
)

/** <fermata>
  *
  * An indication placed over a note or rest to indicate that it should be held longer than its written value. May also occur over a bar line to indicate the end of a phrase or section. Sometimes called a 'hold' or 'pause'.
  */
case class Fermata(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <fermata> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <fermata> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <fermata> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <fermata> -> att.fermata.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <fermata> -> att.fermata.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <fermata> -> att.fermata.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <fermata> -> att.fermata.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <fermata> -> att.fermata.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <fermata> -> att.fermata.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <fermata> -> att.fermata.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <fermata> -> att.fermata.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <fermata> -> att.fermata.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <fermata> -> att.fermata.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <fermata> -> att.fermata.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <fermata> -> att.fermata.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <fermata> -> att.fermata.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <fermata> -> att.fermata.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Describes the visual appearance of the fermata; that is, whether it occurs as upright or inverted.
      *
      * <fermata> -> att.fermata.vis -> att.fermata.vis.attribute.form -> @form
      */
    `@form`: scala.Option[java.lang.String] = scala.None,
    /** Describes the visual appearance of the fermata; that is, whether it has a curved, square, or angular shape.
      *
      * <fermata> -> att.fermata.vis -> att.fermata.vis.attribute.shape -> @shape
      */
    `@shape`: scala.Option[java.lang.String] = scala.None,
)

/** <fTrem>
  *
  * (fingered tremolo) A rapid alternation between a pair of notes (or chords or perhaps between a note and a chord) that are (usually) farther apart than a major second.
  */
case class FTrem(
    /** <fTrem> -> chord -> <chord> (-> Chord)
      * <fTrem> -> clef -> <clef> (-> Clef)
      * <fTrem> -> note -> <note> (-> Note)
      */
    elements: scala.List[Chord | Clef | Note] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <fTrem> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <fTrem> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <fTrem> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <fTrem> -> att.fTrem.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <fTrem> -> att.fTrem.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Records the number of augmentation dots required by a written dotted duration.
      *
      * <fTrem> -> att.fTrem.log -> att.augmentDots -> att.augmentDots.attribute.dots -> @dots
      */
    `@dots`: scala.Option[DataAUGMENTDOT] = scala.None,
    /** (duration) Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
      *
      * <fTrem> -> att.fTrem.log -> att.duration.log -> att.duration.log.attribute.dur -> @dur
      */
    `@dur`: scala.Option[DataDURATION] = scala.None,
    /** Describes the style of the tremolo.
      *
      * <fTrem> -> att.fTrem.log -> att.tremForm -> att.tremForm.attribute.form -> @form
      */
    `@form`: scala.Option[java.lang.String] = scala.None,
    /** The performed duration of an individual note in a measured tremolo.
      *
      * <fTrem> -> att.fTrem.ges -> att.tremMeasured -> att.tremMeasured.attribute.unitdur -> @unitdur
      */
    `@unitdur`: scala.Option[DataDURATIONCmn] = scala.None,
)

/** <gliss>
  *
  * (glissando) A continuous or sliding movement from one pitch to another, usually indicated by a straight or wavy line.
  */
case class Gliss(
    /** <gliss> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <gliss> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <gliss> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <gliss> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <gliss> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <gliss> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <gliss> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <gliss> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <gliss> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <gliss> -> att.gliss.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <gliss> -> att.gliss.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <gliss> -> att.gliss.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <gliss> -> att.gliss.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <gliss> -> att.gliss.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <gliss> -> att.gliss.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <gliss> -> att.gliss.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <gliss> -> att.gliss.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <gliss> -> att.gliss.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <gliss> -> att.gliss.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <gliss> -> att.gliss.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <gliss> -> att.gliss.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <gliss> -> att.gliss.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Contains the name of a font-family.
      *
      * <gliss> -> att.gliss.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <gliss> -> att.gliss.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <gliss> -> att.gliss.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <gliss> -> att.gliss.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <gliss> -> att.gliss.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <gliss> -> att.gliss.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <gliss> -> att.gliss.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <gliss> -> att.gliss.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <gliss> -> att.gliss.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <gliss> -> att.gliss.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <gliss> -> att.gliss.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined start point.
      *
      * <gliss> -> att.gliss.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.startvo -> @startvo
      */
    `@startvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined end point.
      *
      * <gliss> -> att.gliss.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.endvo -> @endvo
      */
    `@endvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Describes the style of a line.
      *
      * <gliss> -> att.gliss.vis -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <gliss> -> att.gliss.vis -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <gliss> -> att.gliss.vis -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <gliss> -> att.gliss.vis -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <gliss> -> att.gliss.vis -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <gliss> -> att.gliss.vis -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <gliss> -> att.gliss.vis -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
)

/** <graceGrp>
  *
  * (grace group) A container for a sequence of grace notes.
  */
case class GraceGrp(
    /** <graceGrp> -> model.eventLike.cmn -> bTrem -> <bTrem> (-> BTrem)
      * <graceGrp> -> model.eventLike.cmn -> beam -> <beam> (-> Beam)
      * <graceGrp> -> model.eventLike.cmn -> beatRpt -> <beatRpt> (-> BeatRpt)
      * <graceGrp> -> model.eventLike -> chord -> <chord> (-> Chord)
      * <graceGrp> -> model.eventLike -> clef -> <clef> (-> Clef)
      * <graceGrp> -> model.eventLike -> clefGrp -> <clefGrp> (-> ClefGrp)
      * <graceGrp> -> model.eventLike.cmn -> fTrem -> <fTrem> (-> FTrem)
      * <graceGrp> -> model.eventLike.cmn -> graceGrp -> <graceGrp> (-> GraceGrp)
      * <graceGrp> -> model.eventLike.cmn -> halfmRpt -> <halfmRpt> (-> HalfmRpt)
      * <graceGrp> -> model.eventLike -> note -> <note> (-> Note)
      * <graceGrp> -> model.eventLike -> rest -> <rest> (-> Rest)
      * <graceGrp> -> model.eventLike -> space -> <space> (-> Space)
      * <graceGrp> -> model.eventLike -> tabGrp -> <tabGrp> (-> TabGrp)
      * <graceGrp> -> model.eventLike.cmn -> tuplet -> <tuplet> (-> Tuplet)
      */
    elements: scala.List[
      BTrem | Beam | BeatRpt | Chord | Clef | ClefGrp | FTrem | GraceGrp | HalfmRpt | Note | Rest | Space | TabGrp |
        Tuplet,
    ] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <graceGrp> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <graceGrp> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <graceGrp> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <graceGrp> -> att.graceGrp.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <graceGrp> -> att.graceGrp.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Marks a note or chord as a "grace" (without a definite performed duration) and records from which other note/chord it should "steal" time.
      *
      * <graceGrp> -> att.graceGrp.log -> att.graced -> att.graced.attribute.grace -> @grace
      */
    `@grace`: scala.Option[DataGRACE] = scala.None,
    /** Records the amount of time to be "stolen" from a non-grace note/chord.
      *
      * <graceGrp> -> att.graceGrp.log -> att.graced -> att.graced.attribute.grace.time -> @grace.time
      */
    `@grace.time`: scala.Option[DataPERCENT] = scala.None,
    /** Records whether the grace note group is attached to the following event or to the preceding one. The usual name for the latter is "Nachschlag".
      *
      * <graceGrp> -> att.graceGrp.log -> att.graceGrp.log.attribute.attach -> @attach
      */
    `@attach`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <graceGrp> -> att.graceGrp.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
)

/** <hairpin>
  *
  * Indicates continuous dynamics expressed on the score as wedge-shaped graphics, e.g., < and >.
  */
case class Hairpin(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <hairpin> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <hairpin> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <hairpin> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <hairpin> -> att.hairpin.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <hairpin> -> att.hairpin.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <hairpin> -> att.hairpin.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <hairpin> -> att.hairpin.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <hairpin> -> att.hairpin.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <hairpin> -> att.hairpin.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <hairpin> -> att.hairpin.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <hairpin> -> att.hairpin.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Captures the visual rendition and function of the hairpin; that is, whether it indicates an increase or a decrease in volume.
      *
      * <hairpin> -> att.hairpin.log -> att.hairpin.log.attribute.form -> @form
      */
    `@form`: java.lang.String,
    /** Indicates that the hairpin starts from or ends in silence. Often rendered as a small circle attached to the closed end of the hairpin. See Gould, p. 108.
      *
      * <hairpin> -> att.hairpin.log -> att.hairpin.log.attribute.niente -> @niente
      */
    `@niente`: scala.Option[DataBOOLEAN] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <hairpin> -> att.hairpin.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes the style of a line.
      *
      * <hairpin> -> att.hairpin.vis -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <hairpin> -> att.hairpin.vis -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <hairpin> -> att.hairpin.vis -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <hairpin> -> att.hairpin.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <hairpin> -> att.hairpin.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <hairpin> -> att.hairpin.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <hairpin> -> att.hairpin.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <hairpin> -> att.hairpin.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined start point.
      *
      * <hairpin> -> att.hairpin.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.startvo -> @startvo
      */
    `@startvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined end point.
      *
      * <hairpin> -> att.hairpin.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.endvo -> @endvo
      */
    `@endvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Specifies the distance between the lines at the open end of a hairpin dynamic mark.
      *
      * <hairpin> -> att.hairpin.vis -> att.hairpin.vis.attribute.opening -> @opening
      */
    `@opening`: scala.Option[DataMEASUREMENTUNSIGNED] = scala.None,
    /** Applies to a "Rossini" hairpin, i.e., one where the normally open side is closed by a connecting line.
      *
      * <hairpin> -> att.hairpin.vis -> att.hairpin.vis.attribute.closed -> @closed
      */
    `@closed`: scala.Option[DataBOOLEAN] = scala.None,
    /** Indicates that the opening points are aligned with an imaginary line that is always 90° perpendicular to the horizontal plane, regardless of any angle or start/end adjustments, including when the hairpin is angled with @angle.optimize or through @endvo/@startvo adjustments.
      *
      * <hairpin> -> att.hairpin.vis -> att.hairpin.vis.attribute.opening.vertical -> @opening.vertical
      */
    `@opening.vertical`: scala.Option[DataBOOLEAN] = scala.None,
    /** Indicates that the slope of the hairpin can be adjusted to follow the content in order to optimize spacing.
      *
      * <hairpin> -> att.hairpin.vis -> att.hairpin.vis.attribute.angle.optimize -> @angle.optimize
      */
    `@angle.optimize`: scala.Option[DataBOOLEAN] = scala.None,
    /** MIDI number.
      *
      * <hairpin> -> att.hairpin.ges -> att.midiValue -> att.midiValue.attribute.val -> @val
      */
    `@val`: scala.Option[DataMIDIVALUE] = scala.None,
    /** MIDI number.
      *
      * <hairpin> -> att.hairpin.ges -> att.midiValue2 -> att.midiValue2.attribute.val2 -> @val2
      */
    `@val2`: scala.Option[DataMIDIVALUE] = scala.None,
)

/** <halfmRpt>
  *
  * (half-measure repeat) A half-measure repeat in any meter.
  */
case class HalfmRpt(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <halfmRpt> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <halfmRpt> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <halfmRpt> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <halfmRpt> -> att.halfmRpt.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <halfmRpt> -> att.halfmRpt.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <halfmRpt> -> att.halfmRpt.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Indicates whether to render a repeat symbol or the source material to which it refers. A value of 'true' renders the source material, while 'false' displays the repeat symbol.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.expandable -> att.expandable.attribute.expand -> @expand
      */
    `@expand`: scala.Option[DataBOOLEAN] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Contains the name of a font-family.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <halfmRpt> -> att.halfmRpt.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <harpPedal>
  *
  * (harp pedal) Harp pedal diagram.
  */
case class HarpPedal(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <harpPedal> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <harpPedal> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <harpPedal> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <harpPedal> -> att.harpPedal.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <harpPedal> -> att.harpPedal.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <harpPedal> -> att.harpPedal.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <harpPedal> -> att.harpPedal.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <harpPedal> -> att.harpPedal.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <harpPedal> -> att.harpPedal.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Indicates the pedal setting for the harp’s C strings.
      *
      * <harpPedal> -> att.harpPedal.log -> att.harpPedal.log.attribute.c -> @c
      */
    `@c`: scala.Option[DataHARPPEDALPOSITION] = scala.None,
    /** Indicates the pedal setting for the harp’s D strings.
      *
      * <harpPedal> -> att.harpPedal.log -> att.harpPedal.log.attribute.d -> @d
      */
    `@d`: scala.Option[DataHARPPEDALPOSITION] = scala.None,
    /** Indicates the pedal setting for the harp’s E strings.
      *
      * <harpPedal> -> att.harpPedal.log -> att.harpPedal.log.attribute.e -> @e
      */
    `@e`: scala.Option[DataHARPPEDALPOSITION] = scala.None,
    /** Indicates the pedal setting for the harp’s F strings.
      *
      * <harpPedal> -> att.harpPedal.log -> att.harpPedal.log.attribute.f -> @f
      */
    `@f`: scala.Option[DataHARPPEDALPOSITION] = scala.None,
    /** Indicates the pedal setting for the harp’s G strings.
      *
      * <harpPedal> -> att.harpPedal.log -> att.harpPedal.log.attribute.g -> @g
      */
    `@g`: scala.Option[DataHARPPEDALPOSITION] = scala.None,
    /** Indicates the pedal setting for the harp’s A strings.
      *
      * <harpPedal> -> att.harpPedal.log -> att.harpPedal.log.attribute.a -> @a
      */
    `@a`: scala.Option[DataHARPPEDALPOSITION] = scala.None,
    /** Indicates the pedal setting for the harp’s B strings.
      *
      * <harpPedal> -> att.harpPedal.log -> att.harpPedal.log.attribute.b -> @b
      */
    `@b`: scala.Option[DataHARPPEDALPOSITION] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <harpPedal> -> att.harpPedal.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <harpPedal> -> att.harpPedal.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <lv>
  *
  * (laissez vibrer) A "tie-like" indication that a note should ring beyond its written duration.
  */
case class Lv(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <lv> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <lv> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <lv> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <lv> -> att.lv.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <lv> -> att.lv.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <lv> -> att.lv.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <lv> -> att.lv.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <lv> -> att.lv.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <lv> -> att.lv.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <lv> -> att.lv.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <lv> -> att.lv.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes a curve with a generic term indicating the direction of curvature.
      *
      * <lv> -> att.lv.vis -> att.curvature -> att.curvature.attribute.curvedir -> @curvedir
      */
    `@curvedir`: scala.Option[java.lang.String] = scala.None,
    /** Describes the style of a line.
      *
      * <lv> -> att.lv.vis -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <lv> -> att.lv.vis -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <lv> -> att.lv.vis -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <lv> -> att.lv.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <lv> -> att.lv.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <lv> -> att.lv.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <lv> -> att.lv.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined start point.
      *
      * <lv> -> att.lv.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.startvo -> @startvo
      */
    `@startvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined end point.
      *
      * <lv> -> att.lv.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.endvo -> @endvo
      */
    `@endvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <measure>
  *
  * Unit of musical time consisting of a fixed number of note values of a given type, as determined by the prevailing meter, and delimited in musical notation by bar lines.
  */
case class Measure(
    /** <measure> -> model.measurePart -> model.controlEventLike.cmn -> arpeg -> <arpeg> (-> Arpeg)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> breath -> <breath> (-> Breath)
      * <measure> -> model.measurePart -> model.controlEventLike -> caesura -> <caesura> (-> Caesura)
      * <measure> -> model.measurePart -> model.controlEventLike -> dir -> <dir> (-> Dir)
      * <measure> -> model.measurePart -> model.controlEventLike -> dynam -> <dynam> (-> Dynam)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> fermata -> <fermata> (-> Fermata)
      * <measure> -> model.measurePart -> model.controlEventLike -> model.fingeringLike -> fing -> <fing> (-> Fing)
      * <measure> -> model.measurePart -> model.controlEventLike -> model.fingeringLike -> fingGrp -> <fingGrp> (-> FingGrp)
      * <measure> -> model.measurePart -> model.controlEventLike -> gliss -> <gliss> (-> Gliss)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> hairpin -> <hairpin> (-> Hairpin)
      * <measure> -> model.measurePart -> model.controlEventLike -> model.controlEventLike.harmony -> model.harmLike -> harm -> <harm> (-> Harm)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> harpPedal -> <harpPedal> (-> HarpPedal)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> lv -> <lv> (-> Lv)
      * <measure> -> mNum -> <mNum> (-> MNum)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> model.ornamentLike.cmn -> mordent -> <mordent> (-> Mordent)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> octave -> <octave> (-> Octave)
      * <measure> -> model.measurePart -> model.controlEventLike -> ornam -> <ornam> (-> Ornam)
      * <measure> -> model.milestoneLike.music -> model.pbLike -> pb -> <pb> (-> Pb)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> pedal -> <pedal> (-> Pedal)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> reh -> <reh> (-> Reh)
      * <measure> -> model.measurePart -> model.controlEventLike -> repeatMark -> <repeatMark> (-> RepeatMark)
      * <measure> -> model.milestoneLike.music -> sb -> <sb> (-> Sb)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> slur -> <slur> (-> Slur)
      * <measure> -> model.measurePart -> model.staffLike -> staff -> <staff> (-> Staff)
      * <measure> -> model.measurePart -> model.controlEventLike -> tempo -> <tempo> (-> Tempo)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> tie -> <tie> (-> Tie)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> model.ornamentLike.cmn -> trill -> <trill> (-> Trill)
      * <measure> -> model.measurePart -> model.controlEventLike.cmn -> model.ornamentLike.cmn -> turn -> <turn> (-> Turn)
      */
    elements: scala.List[
      Arpeg | Breath | Caesura | Dir | Dynam | Fermata | Fing | FingGrp | Gliss | Hairpin | Harm | HarpPedal | Lv |
        MNum | Mordent | Octave | Ornam | Pb | Pedal | Reh | RepeatMark | Sb | Slur | Staff | Tempo | Tie | Trill | Turn,
    ] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <measure> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <measure> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <measure> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Indicates the relationship between the content of a measure and the prevailing meter.
      *
      * <measure> -> att.measure.log -> att.meterConformance.bar -> att.meterConformance.bar.attribute.metcon -> @metcon
      */
    `@metcon`: scala.Option[DataBOOLEAN] = scala.None,
    /** Indicates the visual rendition of the left bar line. It is present here only for facilitation of translation from legacy encodings which use it. Usually, it can be safely ignored.
      *
      * <measure> -> att.measure.log -> att.measure.log.attribute.left -> @left
      */
    `@left`: scala.Option[DataBARRENDITION] = scala.None,
    /** Indicates the function of the right bar line and is structurally important.
      *
      * <measure> -> att.measure.log -> att.measure.log.attribute.right -> @right
      */
    `@right`: scala.Option[DataBARRENDITION] = scala.None,
    /** Provides a number-like designation that indicates an element’s position in a sequence of similar elements. May not contain space characters.
      *
      * <measure> -> att.nNumberLike -> att.nNumberLike.attribute.n -> @n
      */
    `@n`: scala.Option[DataWORD] = scala.None,
)

/** <mNum>
  *
  * (measure number) Designation, name, or label for a measure, often but not always consisting of digits. Use this element when the @n attribute on <measure> does not adequately capture the appearance or placement of the measure number/label.
  */
case class MNum(
    /** <mNum> -> model.lbLike -> lb -> <lb> (-> Lb)
      * <mNum> -> model.rendLike -> rend -> <rend> (-> Rend)
      * <mNum> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | Rend | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <mNum> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <mNum> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <mNum> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <mNum> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <mNum> -> att.mNum.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <mNum> -> att.mNum.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <mNum> -> att.mNum.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <mNum> -> att.mNum.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <mNum> -> att.mNum.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <mNum> -> att.mNum.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <mNum> -> att.mNum.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <mNum> -> att.mNum.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <mNum> -> att.mNum.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <mNum> -> att.mNum.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <mNum> -> att.mNum.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <mRest>
  *
  * (measure rest) Complete measure rest in any meter.
  */
case class MRest(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <mRest> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <mRest> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <mRest> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** <mRest> -> att.mRest.log -> att.cue -> att.cue.attribute.cue -> @cue
      */
    `@cue`: scala.Option[DataBOOLEAN] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <mRest> -> att.mRest.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <mRest> -> att.mRest.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <mRest> -> att.mRest.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <mRest> -> att.mRest.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** "Cut-out" style.
      *
      * <mRest> -> att.mRest.vis -> att.cutout -> att.cutout.attribute.cutout -> @cutout
      */
    `@cutout`: scala.Option[java.lang.String] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <mRest> -> att.mRest.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <mRest> -> att.mRest.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <mRest> -> att.mRest.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <mRest> -> att.mRest.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Captures staff location in terms of written pitch name.
      *
      * <mRest> -> att.mRest.vis -> att.staffLoc.pitched -> att.staffLoc.pitched.attribute.ploc -> @ploc
      */
    `@ploc`: scala.Option[DataPITCHNAME] = scala.None,
    /** Records staff location in terms of written octave.
      *
      * <mRest> -> att.mRest.vis -> att.staffLoc.pitched -> att.staffLoc.pitched.attribute.oloc -> @oloc
      */
    `@oloc`: scala.Option[DataOCTAVE] = scala.None,
    /** Contains the name of a font-family.
      *
      * <mRest> -> att.mRest.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <mRest> -> att.mRest.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <mRest> -> att.mRest.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <mRest> -> att.mRest.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <mRest> -> att.mRest.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <mRest> -> att.mRest.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <mRest> -> att.mRest.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <mRest> -> att.mRest.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <mRest> -> att.mRest.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <mRpt>
  *
  * (measure repeat) An indication that the previous measure should be repeated.
  */
case class MRpt(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <mRpt> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <mRpt> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <mRpt> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <mRpt> -> att.mRpt.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <mRpt> -> att.mRpt.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (number) Records a number or count accompanying a notational feature.
      *
      * <mRpt> -> att.mRpt.log -> att.numbered -> att.numbered.attribute.num -> @num
      */
    `@num`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <mRpt> -> att.mRpt.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Indicates whether to render a repeat symbol or the source material to which it refers. A value of 'true' renders the source material, while 'false' displays the repeat symbol.
      *
      * <mRpt> -> att.mRpt.vis -> att.expandable -> att.expandable.attribute.expand -> @expand
      */
    `@expand`: scala.Option[DataBOOLEAN] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <mRpt> -> att.mRpt.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <mRpt> -> att.mRpt.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <mRpt> -> att.mRpt.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <mRpt> -> att.mRpt.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** (number placement) States where the tuplet number will be placed in relation to the note heads.
      *
      * <mRpt> -> att.mRpt.vis -> att.numberPlacement -> att.numberPlacement.attribute.num.place -> @num.place
      */
    `@num.place`: scala.Option[DataSTAFFRELBasic] = scala.None,
    /** Determines if the tuplet number is visible.
      *
      * <mRpt> -> att.mRpt.vis -> att.numberPlacement -> att.numberPlacement.attribute.num.visible -> @num.visible
      */
    `@num.visible`: scala.Option[DataBOOLEAN] = scala.None,
    /** Contains the name of a font-family.
      *
      * <mRpt> -> att.mRpt.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <mRpt> -> att.mRpt.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <mRpt> -> att.mRpt.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <mRpt> -> att.mRpt.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <mRpt> -> att.mRpt.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <mRpt> -> att.mRpt.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <mRpt> -> att.mRpt.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
)

/** <multiRest>
  *
  * (multimeasure rest) Multiple full measure rests compressed into a single bar, frequently found in performer parts.
  */
case class MultiRest(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <multiRest> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <multiRest> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <multiRest> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <multiRest> -> att.multiRest.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <multiRest> -> att.multiRest.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (number) Records a number or count accompanying a notational feature.
      *
      * <multiRest> -> att.multiRest.log -> att.numbered -> att.numbered.attribute.num -> @num
      */
    `@num`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <multiRest> -> att.multiRest.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <multiRest> -> att.multiRest.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <multiRest> -> att.multiRest.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <multiRest> -> att.multiRest.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <multiRest> -> att.multiRest.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** (number placement) States where the tuplet number will be placed in relation to the note heads.
      *
      * <multiRest> -> att.multiRest.vis -> att.numberPlacement -> att.numberPlacement.attribute.num.place -> @num.place
      */
    `@num.place`: scala.Option[DataSTAFFRELBasic] = scala.None,
    /** Determines if the tuplet number is visible.
      *
      * <multiRest> -> att.multiRest.vis -> att.numberPlacement -> att.numberPlacement.attribute.num.visible -> @num.visible
      */
    `@num.visible`: scala.Option[DataBOOLEAN] = scala.None,
    /** Captures staff location in terms of written pitch name.
      *
      * <multiRest> -> att.multiRest.vis -> att.staffLoc.pitched -> att.staffLoc.pitched.attribute.ploc -> @ploc
      */
    `@ploc`: scala.Option[DataPITCHNAME] = scala.None,
    /** Records staff location in terms of written octave.
      *
      * <multiRest> -> att.multiRest.vis -> att.staffLoc.pitched -> att.staffLoc.pitched.attribute.oloc -> @oloc
      */
    `@oloc`: scala.Option[DataOCTAVE] = scala.None,
    /** Contains the name of a font-family.
      *
      * <multiRest> -> att.multiRest.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <multiRest> -> att.multiRest.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <multiRest> -> att.multiRest.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <multiRest> -> att.multiRest.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <multiRest> -> att.multiRest.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <multiRest> -> att.multiRest.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <multiRest> -> att.multiRest.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Measurement of the horizontal dimension of an entity.
      *
      * <multiRest> -> att.multiRest.vis -> att.width -> att.width.attribute.width -> @width
      */
    `@width`: scala.Option[DataMEASUREMENTUNSIGNED] = scala.None,
    /** The block attribute controls whether the multimeasure rest should be rendered as a block rest or as church rests ("Kirchenpausen"), that are combinations of longa, breve and semibreve rests.
      *
      * <multiRest> -> att.multiRest.vis -> att.multiRest.vis.attribute.block -> @block
      */
    `@block`: scala.Option[DataBOOLEAN] = scala.None,
)

/** <multiRpt>
  *
  * (multiple repeat) Multiple repeated measures.
  */
case class MultiRpt(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <multiRpt> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <multiRpt> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <multiRpt> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <multiRpt> -> att.multiRpt.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <multiRpt> -> att.multiRpt.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (number) Records a number or count accompanying a notational feature.
      *
      * <multiRpt> -> att.multiRpt.log -> att.numbered -> att.numbered.attribute.num -> @num
      */
    `@num`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Indicates whether to render a repeat symbol or the source material to which it refers. A value of 'true' renders the source material, while 'false' displays the repeat symbol.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.expandable -> att.expandable.attribute.expand -> @expand
      */
    `@expand`: scala.Option[DataBOOLEAN] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <multiRpt> -> att.multiRpt.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Contains the name of a font-family.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <multiRpt> -> att.multiRpt.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
)

/** <octave>
  *
  * An indication that a passage should be performed one or more octaves above or below its written pitch.
  */
case class Octave(
    /** <octave> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <octave> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <octave> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <octave> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <octave> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <octave> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <octave> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <octave> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <octave> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <octave> -> att.octave.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <octave> -> att.octave.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <octave> -> att.octave.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <octave> -> att.octave.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <octave> -> att.octave.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Records the amount of octave displacement.
      *
      * <octave> -> att.octave.log -> att.octaveDisplacement -> att.octaveDisplacement.attribute.dis -> @dis
      */
    `@dis`: scala.Option[DataOCTAVEDIS] = scala.None,
    /** Records the direction of octave displacement.
      *
      * <octave> -> att.octave.log -> att.octaveDisplacement -> att.octaveDisplacement.attribute.dis.place -> @dis.place
      */
    `@dis.place`: scala.Option[DataSTAFFRELBasic] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <octave> -> att.octave.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <octave> -> att.octave.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <octave> -> att.octave.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Indicates whether the octave displacement should be performed simultaneously with the written notes, i.e., "coll' ottava". Unlike other octave signs which are indicated by broken lines, coll' ottava typically uses an unbroken line or a series of longer broken lines, ending with a short vertical stroke. See Read, p. 47-48.
      *
      * <octave> -> att.octave.log -> att.octave.log.attribute.coll -> @coll
      */
    `@coll`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <octave> -> att.octave.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes the style of a line.
      *
      * <octave> -> att.octave.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <octave> -> att.octave.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <octave> -> att.octave.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <octave> -> att.octave.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <octave> -> att.octave.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <octave> -> att.octave.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <octave> -> att.octave.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Indicates the presence of an extension symbol, typically a line.
      *
      * <octave> -> att.octave.vis -> att.extender -> att.extender.attribute.extender -> @extender
      */
    `@extender`: scala.Option[DataBOOLEAN] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <octave> -> att.octave.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <octave> -> att.octave.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <octave> -> att.octave.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <octave> -> att.octave.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <pedal>
  *
  * Piano pedal mark.
  */
case class Pedal(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <pedal> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <pedal> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <pedal> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <pedal> -> att.pedal.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <pedal> -> att.pedal.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <pedal> -> att.pedal.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <pedal> -> att.pedal.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <pedal> -> att.pedal.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <pedal> -> att.pedal.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <pedal> -> att.pedal.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** (direction) Records the position of the piano damper pedal.
      *
      * <pedal> -> att.pedal.log -> att.pedal.log.attribute.dir -> @dir
      */
    `@dir`: java.lang.String,
    /** (function) Indicates the function of the depressed pedal, but not necessarily the text associated with its use. Use the <dir> element for such text.
      * Suggested values include: 1] sustain; 2] soft; 3] sostenuto; 4] silent
      *
      * <pedal> -> att.pedal.log -> att.pedal.log.attribute.func -> @func
      */
    `@func`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <pedal> -> att.pedal.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <pedal> -> att.pedal.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <pedal> -> att.pedal.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <pedal> -> att.pedal.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <pedal> -> att.pedal.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Describes the style of a line.
      *
      * <pedal> -> att.pedal.vis -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <pedal> -> att.pedal.vis -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <pedal> -> att.pedal.vis -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <pedal> -> att.pedal.vis -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <pedal> -> att.pedal.vis -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <pedal> -> att.pedal.vis -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <pedal> -> att.pedal.vis -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <pedal> -> att.pedal.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <pedal> -> att.pedal.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <pedal> -> att.pedal.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <pedal> -> att.pedal.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <pedal> -> att.pedal.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <pedal> -> att.pedal.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <pedal> -> att.pedal.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <pedal> -> att.pedal.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <pedal> -> att.pedal.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <pedal> -> att.pedal.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Determines whether piano pedal marks should be rendered as lines or as terms.
      *
      * <pedal> -> att.pedal.vis -> att.pedal.vis.attribute.form -> @form
      */
    `@form`: scala.Option[DataPEDALSTYLE] = scala.None,
)

/** <reh>
  *
  * (rehearsal mark) In an orchestral score and its corresponding parts, a mark indicating a convenient point from which to resume rehearsal after a break.
  */
case class Reh(
    /** <reh> -> model.lbLike -> lb -> <lb> (-> Lb)
      * <reh> -> model.rendLike -> rend -> <rend> (-> Rend)
      * <reh> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | Rend | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <reh> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <reh> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <reh> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <reh> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <reh> -> att.reh.log -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <reh> -> att.reh.log -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <reh> -> att.reh.log -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <reh> -> att.reh.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <reh> -> att.reh.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <reh> -> att.reh.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <reh> -> att.reh.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <reh> -> att.reh.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <reh> -> att.reh.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <reh> -> att.reh.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <reh> -> att.reh.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <reh> -> att.reh.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <reh> -> att.reh.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <reh> -> att.reh.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <repeatMark>
  *
  * (repetition mark) An instruction expressed as a combination of text and symbols – segno and coda – typically above, below, or between staves, but not on the staff.
  */
case class RepeatMark(
    /** <repeatMark> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <repeatMark> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <repeatMark> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <repeatMark> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <repeatMark> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <repeatMark> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <repeatMark> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <repeatMark> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <repeatMark> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <repeatMark> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <repeatMark> -> att.repeatMark.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <repeatMark> -> att.repeatMark.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <repeatMark> -> att.repeatMark.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <repeatMark> -> att.repeatMark.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <repeatMark> -> att.repeatMark.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <repeatMark> -> att.repeatMark.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <repeatMark> -> att.repeatMark.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <repeatMark> -> att.repeatMark.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Indicates the function of the mark, usually implying a corresponding form.
      *
      * <repeatMark> -> att.repeatMark.log -> att.repeatMark.log.attribute.func -> @func
      */
    `@func`: java.lang.String,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes the style of a line.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Indicates the presence of an extension symbol, typically a line.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extender -> att.extender.attribute.extender -> @extender
      */
    `@extender`: scala.Option[DataBOOLEAN] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <repeatMark> -> att.repeatMark.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <slur>
  *
  * Indication of 1) a "unified melodic idea" or 2) performance technique.
  */
case class Slur(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <slur> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <slur> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <slur> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <slur> -> att.slur.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <slur> -> att.slur.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <slur> -> att.slur.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <slur> -> att.slur.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <slur> -> att.slur.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <slur> -> att.slur.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <slur> -> att.slur.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <slur> -> att.slur.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <slur> -> att.slur.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes a curve with a generic term indicating the direction of curvature.
      *
      * <slur> -> att.slur.vis -> att.curvature -> att.curvature.attribute.curvedir -> @curvedir
      */
    `@curvedir`: scala.Option[java.lang.String] = scala.None,
    /** Describes the style of a line.
      *
      * <slur> -> att.slur.vis -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <slur> -> att.slur.vis -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <slur> -> att.slur.vis -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <slur> -> att.slur.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <slur> -> att.slur.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <slur> -> att.slur.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <slur> -> att.slur.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined start point.
      *
      * <slur> -> att.slur.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.startvo -> @startvo
      */
    `@startvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined end point.
      *
      * <slur> -> att.slur.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.endvo -> @endvo
      */
    `@endvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <tie>
  *
  * An indication that two notes of the same pitch form a single note with their combined rhythmic values.
  */
case class Tie(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <tie> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <tie> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <tie> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <tie> -> att.tie.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <tie> -> att.tie.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <tie> -> att.tie.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <tie> -> att.tie.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <tie> -> att.tie.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <tie> -> att.tie.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <tie> -> att.tie.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <tie> -> att.tie.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes a curve with a generic term indicating the direction of curvature.
      *
      * <tie> -> att.tie.vis -> att.curvature -> att.curvature.attribute.curvedir -> @curvedir
      */
    `@curvedir`: scala.Option[java.lang.String] = scala.None,
    /** Describes the style of a line.
      *
      * <tie> -> att.tie.vis -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <tie> -> att.tie.vis -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <tie> -> att.tie.vis -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <tie> -> att.tie.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <tie> -> att.tie.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <tie> -> att.tie.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <tie> -> att.tie.vis -> att.visualOffset2 -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined start point.
      *
      * <tie> -> att.tie.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.startvo -> @startvo
      */
    `@startvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records a vertical adjustment of a feature’s programmatically-determined end point.
      *
      * <tie> -> att.tie.vis -> att.visualOffset2 -> att.visualOffset2.vo -> att.visualOffset2.vo.attribute.endvo -> @endvo
      */
    `@endvo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <tuplet>
  *
  * A group of notes with "irregular" (sometimes called "irrational") rhythmic values, for example, three notes in the time normally occupied by two or nine in the time of five.
  */
case class Tuplet(
    /** <tuplet> -> model.eventLike.cmn -> bTrem -> <bTrem> (-> BTrem)
      * <tuplet> -> model.eventLike.cmn -> beam -> <beam> (-> Beam)
      * <tuplet> -> model.eventLike.cmn -> beatRpt -> <beatRpt> (-> BeatRpt)
      * <tuplet> -> model.eventLike -> chord -> <chord> (-> Chord)
      * <tuplet> -> model.eventLike -> clef -> <clef> (-> Clef)
      * <tuplet> -> model.eventLike -> clefGrp -> <clefGrp> (-> ClefGrp)
      * <tuplet> -> model.eventLike.cmn -> fTrem -> <fTrem> (-> FTrem)
      * <tuplet> -> model.eventLike.cmn -> graceGrp -> <graceGrp> (-> GraceGrp)
      * <tuplet> -> model.eventLike.cmn -> halfmRpt -> <halfmRpt> (-> HalfmRpt)
      * <tuplet> -> model.eventLike -> note -> <note> (-> Note)
      * <tuplet> -> model.eventLike -> rest -> <rest> (-> Rest)
      * <tuplet> -> model.eventLike -> space -> <space> (-> Space)
      * <tuplet> -> model.eventLike -> tabGrp -> <tabGrp> (-> TabGrp)
      * <tuplet> -> model.eventLike.cmn -> tuplet -> <tuplet> (-> Tuplet)
      */
    elements: scala.List[
      BTrem | Beam | BeatRpt | Chord | Clef | ClefGrp | FTrem | GraceGrp | HalfmRpt | Note | Rest | Space | TabGrp |
        Tuplet,
    ] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <tuplet> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <tuplet> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <tuplet> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <tuplet> -> att.tuplet.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** (number) Along with numbase, describes duration as a ratio. num is the first value in the ratio, while numbase is the second.
      *
      * <tuplet> -> att.tuplet.log -> att.duration.ratio -> att.duration.ratio.attribute.num -> @num
      */
    `@num`: scala.Option[java.lang.String] = scala.None,
    /** Along with num, describes duration as a ratio. num is the first value in the ratio, while numbase is the second.
      *
      * <tuplet> -> att.tuplet.log -> att.duration.ratio -> att.duration.ratio.attribute.numbase -> @numbase
      */
    `@numbase`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <tuplet> -> att.tuplet.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <tuplet> -> att.tuplet.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <tuplet> -> att.tuplet.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <tuplet> -> att.tuplet.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <tuplet> -> att.tuplet.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** (number placement) States where the tuplet number will be placed in relation to the note heads.
      *
      * <tuplet> -> att.tuplet.vis -> att.numberPlacement -> att.numberPlacement.attribute.num.place -> @num.place
      */
    `@num.place`: scala.Option[DataSTAFFRELBasic] = scala.None,
    /** Determines if the tuplet number is visible.
      *
      * <tuplet> -> att.tuplet.vis -> att.numberPlacement -> att.numberPlacement.attribute.num.visible -> @num.visible
      */
    `@num.visible`: scala.Option[DataBOOLEAN] = scala.None,
    /** Used to state where a tuplet bracket will be placed in relation to the note heads.
      *
      * <tuplet> -> att.tuplet.vis -> att.tuplet.vis.attribute.bracket.place -> @bracket.place
      */
    `@bracket.place`: scala.Option[DataSTAFFRELBasic] = scala.None,
    /** States whether a bracket should be rendered with a tuplet.
      *
      * <tuplet> -> att.tuplet.vis -> att.tuplet.vis.attribute.bracket.visible -> @bracket.visible
      */
    `@bracket.visible`: scala.Option[DataBOOLEAN] = scala.None,
    /** Determines if the tuplet duration is visible.
      *
      * <tuplet> -> att.tuplet.vis -> att.tuplet.vis.attribute.dur.visible -> @dur.visible
      */
    `@dur.visible`: scala.Option[DataBOOLEAN] = scala.None,
    /** Controls how the num:numbase ratio is to be displayed.
      *
      * <tuplet> -> att.tuplet.vis -> att.tuplet.vis.attribute.num.format -> @num.format
      */
    `@num.format`: scala.Option[java.lang.String] = scala.None,
)

/** <mordent>
  *
  * An ornament indicating rapid alternation of the main note with a secondary note, usually a step below, but sometimes a step above.
  */
case class Mordent(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <mordent> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <mordent> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <mordent> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <mordent> -> att.mordent.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <mordent> -> att.mordent.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <mordent> -> att.mordent.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <mordent> -> att.mordent.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <mordent> -> att.mordent.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <mordent> -> att.mordent.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Records the sounding accidental associated with an upper neighboring note.
      *
      * <mordent> -> att.mordent.log -> att.ornamentAccid -> att.ornamentAccid.ges -> att.ornamentAccid.ges.attribute.accidupper.ges -> @accidupper.ges
      */
    `@accidupper.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** Records the sounding accidental associated with a lower neighboring note.
      *
      * <mordent> -> att.mordent.log -> att.ornamentAccid -> att.ornamentAccid.ges -> att.ornamentAccid.ges.attribute.accidlower.ges -> @accidlower.ges
      */
    `@accidlower.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** Records the written accidental associated with an upper neighboring note.
      *
      * <mordent> -> att.mordent.log -> att.ornamentAccid -> att.ornamentAccid.attribute.accidupper -> @accidupper
      */
    `@accidupper`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** Records the written accidental associated with a lower neighboring note.
      *
      * <mordent> -> att.mordent.log -> att.ornamentAccid -> att.ornamentAccid.attribute.accidlower -> @accidlower
      */
    `@accidlower`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** Records semantic meaning, i.e., intended performance, of the mordent. The @altsym, @glyph.name, or @glyph.num attributes may be used to specify the appropriate symbol.
      *
      * <mordent> -> att.mordent.log -> att.mordent.log.attribute.form -> @form
      */
    `@form`: scala.Option[java.lang.String] = scala.None,
    /** When set to 'true', a double or long mordent, sometimes called a "pincé double", consisting of 5 notes, is indicated.
      *
      * <mordent> -> att.mordent.log -> att.mordent.log.attribute.long -> @long
      */
    `@long`: scala.Option[DataBOOLEAN] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <mordent> -> att.mordent.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <mordent> -> att.mordent.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <mordent> -> att.mordent.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <mordent> -> att.mordent.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <mordent> -> att.mordent.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <mordent> -> att.mordent.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <mordent> -> att.mordent.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <mordent> -> att.mordent.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <mordent> -> att.mordent.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <mordent> -> att.mordent.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <mordent> -> att.mordent.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <mordent> -> att.mordent.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <mordent> -> att.mordent.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <mordent> -> att.mordent.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <mordent> -> att.mordent.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <mordent> -> att.mordent.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <trill>
  *
  * Rapid alternation of a note with another (usually at the interval of a second above).
  */
case class Trill(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <trill> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <trill> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <trill> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <trill> -> att.trill.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <trill> -> att.trill.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <trill> -> att.trill.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <trill> -> att.trill.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <trill> -> att.trill.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Records the sounding accidental associated with an upper neighboring note.
      *
      * <trill> -> att.trill.log -> att.ornamentAccid -> att.ornamentAccid.ges -> att.ornamentAccid.ges.attribute.accidupper.ges -> @accidupper.ges
      */
    `@accidupper.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** Records the sounding accidental associated with a lower neighboring note.
      *
      * <trill> -> att.trill.log -> att.ornamentAccid -> att.ornamentAccid.ges -> att.ornamentAccid.ges.attribute.accidlower.ges -> @accidlower.ges
      */
    `@accidlower.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** Records the written accidental associated with an upper neighboring note.
      *
      * <trill> -> att.trill.log -> att.ornamentAccid -> att.ornamentAccid.attribute.accidupper -> @accidupper
      */
    `@accidupper`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** Records the written accidental associated with a lower neighboring note.
      *
      * <trill> -> att.trill.log -> att.ornamentAccid -> att.ornamentAccid.attribute.accidlower -> @accidlower
      */
    `@accidlower`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <trill> -> att.trill.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <trill> -> att.trill.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <trill> -> att.trill.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <trill> -> att.trill.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <trill> -> att.trill.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** Describes the style of a line.
      *
      * <trill> -> att.trill.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <trill> -> att.trill.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <trill> -> att.trill.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <trill> -> att.trill.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <trill> -> att.trill.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <trill> -> att.trill.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <trill> -> att.trill.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Indicates the presence of an extension symbol, typically a line.
      *
      * <trill> -> att.trill.vis -> att.extender -> att.extender.attribute.extender -> @extender
      */
    `@extender`: scala.Option[DataBOOLEAN] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <trill> -> att.trill.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <trill> -> att.trill.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <trill> -> att.trill.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <trill> -> att.trill.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <trill> -> att.trill.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <trill> -> att.trill.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <trill> -> att.trill.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <trill> -> att.trill.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <trill> -> att.trill.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <trill> -> att.trill.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <trill> -> att.trill.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <trill> -> att.trill.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <trill> -> att.trill.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <trill> -> att.trill.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <trill> -> att.trill.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <trill> -> att.trill.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <turn>
  *
  * An ornament consisting of four notes — the upper neighbor of the written note, the written note, the lower neighbor, and the written note.
  */
case class Turn(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <turn> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <turn> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <turn> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <turn> -> att.turn.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <turn> -> att.turn.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <turn> -> att.turn.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <turn> -> att.turn.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Records the sounding accidental associated with an upper neighboring note.
      *
      * <turn> -> att.turn.log -> att.ornamentAccid -> att.ornamentAccid.ges -> att.ornamentAccid.ges.attribute.accidupper.ges -> @accidupper.ges
      */
    `@accidupper.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** Records the sounding accidental associated with a lower neighboring note.
      *
      * <turn> -> att.turn.log -> att.ornamentAccid -> att.ornamentAccid.ges -> att.ornamentAccid.ges.attribute.accidlower.ges -> @accidlower.ges
      */
    `@accidlower.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** Records the written accidental associated with an upper neighboring note.
      *
      * <turn> -> att.turn.log -> att.ornamentAccid -> att.ornamentAccid.attribute.accidupper -> @accidupper
      */
    `@accidupper`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** Records the written accidental associated with a lower neighboring note.
      *
      * <turn> -> att.turn.log -> att.ornamentAccid -> att.ornamentAccid.attribute.accidlower -> @accidlower
      */
    `@accidlower`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <turn> -> att.turn.log -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** When set to 'true', the turn begins on the second half of the beat.
      *
      * <turn> -> att.turn.log -> att.turn.log.attribute.delayed -> @delayed
      */
    `@delayed`: scala.Option[DataBOOLEAN] = scala.None,
    /** Records meaning; i.e., intended performance, of the turn. The @altsym, @glyph.name, or @glyph.num attributes may be used to specify the appropriate symbol.
      *
      * <turn> -> att.turn.log -> att.turn.log.attribute.form -> @form
      */
    `@form`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <turn> -> att.turn.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <turn> -> att.turn.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <turn> -> att.turn.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <turn> -> att.turn.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <turn> -> att.turn.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <turn> -> att.turn.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <turn> -> att.turn.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <turn> -> att.turn.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <turn> -> att.turn.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <turn> -> att.turn.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <turn> -> att.turn.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <turn> -> att.turn.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <turn> -> att.turn.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <turn> -> att.turn.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <turn> -> att.turn.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <turn> -> att.turn.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <fing>
  *
  * (finger) An individual finger in a fingering indication.
  */
case class Fing(
    /** <fing> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <fing> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <fing> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <fing> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <fing> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <fing> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <fing> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <fing> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <fing> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <fing> -> att.fing.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <fing> -> att.fing.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <fing> -> att.fing.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <fing> -> att.fing.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <fing> -> att.fing.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <fing> -> att.fing.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <fing> -> att.fing.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <fing> -> att.fing.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <fing> -> att.fing.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes the style of a line.
      *
      * <fing> -> att.fing.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <fing> -> att.fing.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <fing> -> att.fing.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <fing> -> att.fing.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <fing> -> att.fing.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <fing> -> att.fing.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <fing> -> att.fing.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Indicates the presence of an extension symbol, typically a line.
      *
      * <fing> -> att.fing.vis -> att.extender -> att.extender.attribute.extender -> @extender
      */
    `@extender`: scala.Option[DataBOOLEAN] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <fing> -> att.fing.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <fing> -> att.fing.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <fing> -> att.fing.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <fingGrp>
  *
  * (finger group) A group of individual fingers in a fingering indication.
  */
case class FingGrp(
    /** <fingGrp> -> model.fingeringLike -> fing -> <fing> (-> Fing)
      * <fingGrp> -> model.fingeringLike -> fingGrp -> <fingGrp> (-> FingGrp)
      */
    elements: scala.List[Fing | FingGrp] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <fingGrp> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <fingGrp> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <fingGrp> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <fingGrp> -> att.fingGrp.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <fingGrp> -> att.fingGrp.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <fingGrp> -> att.fingGrp.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <fingGrp> -> att.fingGrp.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <fingGrp> -> att.fingGrp.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <fingGrp> -> att.fingGrp.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <fingGrp> -> att.fingGrp.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <fingGrp> -> att.fingGrp.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** <fingGrp> -> att.fingGrp.log -> att.fingGrp.log.attribute.form -> @form
      */
    `@form`: scala.Option[java.lang.String] = scala.None,
)

/** <chordDef>
  *
  * (chord definition) Chord tablature definition.
  */
case class ChordDef(
    /** <chordDef> -> barre -> <barre> (-> Barre)
      * <chordDef> -> chordMember -> <chordMember> (-> ChordMember)
      */
    elements: scala.List[Barre | ChordMember] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <chordDef> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <chordDef> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <chordDef> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Records fret position.
      *
      * <chordDef> -> att.chordDef.log -> att.stringtab.position -> att.stringtab.position.attribute.tab.pos -> @tab.pos
      */
    `@tab.pos`: scala.Option[java.lang.String] = scala.None,
    /** This attribute is deprecated in favor of the new <tuning> element and will be removed in a future version. Provides a *written* pitch and octave for each open string or course of strings.
      *
      * <chordDef> -> att.chordDef.log -> att.stringtab.tuning -> att.stringtab.tuning.attribute.tab.strings -> @tab.strings
      */
    `@tab.strings`: scala.Option[java.lang.String] = scala.None,
    /** This attribute is deprecated in favor of the new <tuning> element and will be removed in a future version. Provides a *written* pitch and octave for each open string or course of strings.
      *
      * <chordDef> -> att.chordDef.log -> att.stringtab.tuning -> att.stringtab.tuning.attribute.tab.courses -> @tab.courses
      */
    `@tab.courses`: scala.Option[java.lang.String] = scala.None,
)

/** <chordMember>
  *
  * An individual pitch in a chord defined by a <chordDef> element.
  */
case class ChordMember(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <chordMember> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <chordMember> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <chordMember> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Records the performed pitch inflection.
      *
      * <chordMember> -> att.chordMember.ges -> att.accidental.ges -> att.accidental.ges.attribute.accid.ges -> @accid.ges
      */
    `@accid.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** (pitch name) Contains a written pitch name.
      *
      * <chordMember> -> att.chordMember.log -> att.pitched -> att.pitch -> att.pitch.attribute.pname -> @pname
      */
    `@pname`: scala.Option[DataPITCHNAME] = scala.None,
    /** (octave) Captures written octave information.
      *
      * <chordMember> -> att.chordMember.log -> att.pitched -> att.octave -> att.octave.attribute.oct -> @oct
      */
    `@oct`: scala.Option[DataOCTAVE] = scala.None,
    /** This attribute is deprecated and will be removed in a future version. Indicates which finger, if any, should be used to play an individual string. The index, middle, ring, and little fingers are represented by the values 1-4, while t is for the thumb. The values x and o indicate muffled and open strings, respectively.
      *
      * <chordMember> -> att.chordMember.log -> att.stringtab -> att.stringtab.attribute.tab.fing -> @tab.fing
      */
    `@tab.fing`: scala.Option[DataFINGERFRET] = scala.None,
    /** Records the location at which a string should be stopped against a fret.
      *
      * <chordMember> -> att.chordMember.log -> att.stringtab -> att.stringtab.attribute.tab.fret -> @tab.fret
      */
    `@tab.fret`: scala.Option[DataFRETNUMBER] = scala.None,
    /** Used in German lute tablature in cases where vertical positioning deviates from the norm which can be specified by @tab.align. Indicates the position of the tab note on one of the horizontal strands corresponding to the @lines attribute on <staffDef>. (Note that in this case, the lines are conceptual rather than visible).
      *
      * <chordMember> -> att.chordMember.log -> att.stringtab -> att.stringtab.attribute.tab.line -> @tab.line
      */
    `@tab.line`: scala.Option[DataCLEFLINE] = scala.None,
    /** This attribute is deprecated in favor of @tab.course and will be removed in a future version. Records which string is to be played.
      *
      * <chordMember> -> att.chordMember.log -> att.stringtab -> att.stringtab.attribute.tab.string -> @tab.string
      */
    `@tab.string`: scala.Option[DataSTRINGNUMBER] = scala.None,
    /** Records which course is to be played.
      *
      * <chordMember> -> att.chordMember.log -> att.stringtab -> att.stringtab.attribute.tab.course -> @tab.course
      */
    `@tab.course`: scala.Option[DataCOURSENUMBER] = scala.None,
)

/** <f>
  *
  * (figure) Single element of a figured bass indication.
  */
case class F(
    /** <f> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <f> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <f> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <f> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <f> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <f> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <f> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <f> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <f> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <f> -> att.f.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <f> -> att.f.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <f> -> att.f.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <f> -> att.f.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <f> -> att.f.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <f> -> att.f.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <f> -> att.f.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <f> -> att.f.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <f> -> att.f.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes the style of a line.
      *
      * <f> -> att.f.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <f> -> att.f.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <f> -> att.f.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <f> -> att.f.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <f> -> att.f.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <f> -> att.f.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <f> -> att.f.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Indicates the presence of an extension symbol, typically a line.
      *
      * <f> -> att.f.vis -> att.extender -> att.extender.attribute.extender -> @extender
      */
    `@extender`: scala.Option[DataBOOLEAN] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <f> -> att.f.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <f> -> att.f.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <f> -> att.f.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <fb>
  *
  * (figured bass) Symbols added to a bass line that indicate harmony. Used to improvise a chordal accompaniment. Sometimes called Generalbass, thoroughbass, or basso continuo.
  */
case class Fb(
    /** <fb> -> model.fLike -> f -> <f> (-> F)
      */
    elements: scala.List[F] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <fb> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <fb> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <fb> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <harm>
  *
  * (harmony) An indication of harmony, e.g., chord names, tablature grids, harmonic analysis, figured bass.
  */
case class Harm(
    /** <harm> -> model.figbassLike -> fb -> <fb> (-> Fb)
      * <harm> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <harm> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <harm> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <harm> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <harm> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <harm> -> text (-> java.lang.String)
      */
    elements: scala.List[Fb | Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <harm> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <harm> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <harm> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <harm> -> att.harm.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <harm> -> att.harm.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <harm> -> att.harm.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <harm> -> att.harm.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <harm> -> att.harm.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <harm> -> att.harm.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <harm> -> att.harm.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <harm> -> att.harm.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** (chord reference) Contains a reference to a <chordDef> element elsewhere in the document.
      *
      * <harm> -> att.harm.log -> att.harm.log.attribute.chordref -> @chordref
      */
    `@chordref`: scala.Option[DataURI] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <harm> -> att.harm.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes the style of a line.
      *
      * <harm> -> att.harm.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <harm> -> att.harm.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <harm> -> att.harm.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <harm> -> att.harm.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <harm> -> att.harm.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <harm> -> att.harm.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <harm> -> att.harm.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Indicates the presence of an extension symbol, typically a line.
      *
      * <harm> -> att.harm.vis -> att.extender -> att.extender.attribute.extender -> @extender
      */
    `@extender`: scala.Option[DataBOOLEAN] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <harm> -> att.harm.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <harm> -> att.harm.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <harm> -> att.harm.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <harm> -> att.harm.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <harm> -> att.harm.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Describes how the harmonic indication should be rendered.
      *
      * <harm> -> att.harm.vis -> att.harm.vis.attribute.rendgrid -> @rendgrid
      */
    `@rendgrid`: scala.Option[java.lang.String] = scala.None,
)

/** <availability>
  *
  * Groups elements that describe the availability of and access to a bibliographic item, including an MEI-encoded document.
  */
case class Availability(
    /** <availability> -> macro.availabilityPart -> text (-> java.lang.String)
      */
    elements: scala.List[java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <availability> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <availability> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <availability> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Used to link metadata elements to one or more data-containing elements.
      *
      * <availability> -> att.dataPointing -> att.dataPointing.attribute.data -> @data
      */
    `@data`: scala.Option[java.lang.String] = scala.None,
)

/** <fileDesc>
  *
  * (file description) (file description) – Contains a full bibliographic description of the MEI file.
  */
case class FileDesc(
    /** <fileDesc> -> pubStmt -> <pubStmt> (-> PubStmt)
      * <fileDesc> -> titleStmt -> <titleStmt> (-> TitleStmt)
      */
    elements: scala.List[PubStmt | TitleStmt] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <fileDesc> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <fileDesc> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <fileDesc> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Used to point to other elements that correspond to this one in a generic fashion.
      *
      * <fileDesc> -> @corresp
      */
    `@corresp`: scala.Option[java.lang.String] = scala.None,
)

/** <meiHead>
  *
  * (MEI header) (MEI header) – Supplies the descriptive and declarative metadata prefixed to every MEI-conformant text.
  */
case class MeiHead(
    /** <meiHead> -> fileDesc -> <fileDesc> (-> FileDesc)
      */
    elements: scala.List[FileDesc] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <meiHead> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <meiHead> -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <meiHead> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Specifies the kind of document to which the header is attached, for example whether it is a corpus or individual text.
      *
      * <meiHead> -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <pubStmt>
  *
  * (publication statement) (publication statement) – Container for information regarding the publication or distribution of a bibliographic item, including the publisher's name and address, the date of publication, and other relevant details.
  */
case class PubStmt(
    /** <pubStmt> -> availability -> <availability> (-> Availability)
      * <pubStmt> -> date -> <date> (-> Date)
      * <pubStmt> -> pubPlace -> <pubPlace> (-> PubPlace)
      */
    elements: scala.List[Availability | Date | PubPlace] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <pubStmt> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <pubStmt> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <pubStmt> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <titleStmt>
  *
  * (title statement) Container for title and responsibility meta-data.
  */
case class TitleStmt(
    /** <titleStmt> -> model.respLike -> model.respLikePart -> arranger -> <arranger> (-> Arranger)
      * <titleStmt> -> model.respLike -> model.respLikePart -> composer -> <composer> (-> Composer)
      * <titleStmt> -> model.respLike -> model.respLikePart -> lyricist -> <lyricist> (-> Lyricist)
      * <titleStmt> -> model.respLike -> respStmt -> <respStmt> (-> RespStmt)
      * <titleStmt> -> model.titleLike -> title -> <title> (-> Title)
      */
    elements: scala.List[Arranger | Composer | Lyricist | RespStmt | Title] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <titleStmt> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <titleStmt> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <titleStmt> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <refrain>
  *
  * Recurring lyrics, especially at the end of each verse or stanza of a poem or song lyrics; a chorus.
  */
case class Refrain(
    /** <refrain> -> dir -> <dir> (-> Dir)
      * <refrain> -> dynam -> <dynam> (-> Dynam)
      * <refrain> -> model.lbLike -> lb -> <lb> (-> Lb)
      * <refrain> -> space -> <space> (-> Space)
      * <refrain> -> model.sylLike -> syl -> <syl> (-> Syl)
      * <refrain> -> tempo -> <tempo> (-> Tempo)
      * <refrain> -> volta -> <volta> (-> Volta)
      */
    elements: scala.List[Dir | Dynam | Lb | Space | Syl | Tempo | Volta] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <refrain> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <refrain> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <refrain> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <refrain> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <refrain> -> att.refrain.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <refrain> -> att.refrain.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <refrain> -> att.refrain.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <refrain> -> att.refrain.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <refrain> -> att.refrain.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <refrain> -> att.refrain.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <refrain> -> att.refrain.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <refrain> -> att.refrain.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <refrain> -> att.refrain.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <refrain> -> att.refrain.vis -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Specifies the symbol used to group lyrics.
      *
      * <refrain> -> att.refrain.vis -> att.voltaGroupingSym -> att.voltaGroupingSym.attribute.voltasym -> @voltasym
      */
    `@voltasym`: scala.Option[java.lang.String] = scala.None,
)

/** <verse>
  *
  * Division of a poem or song lyrics, sometimes having a fixed length, meter or rhyme scheme; a stanza.
  */
case class Verse(
    /** <verse> -> label -> <label> (-> Label)
      * <verse> -> labelAbbr -> <labelAbbr> (-> LabelAbbr)
      * <verse> -> model.sylLike -> syl -> <syl> (-> Syl)
      * <verse> -> volta -> <volta> (-> Volta)
      */
    elements: scala.List[Label | LabelAbbr | Syl | Volta] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <verse> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <verse> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <verse> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <verse> -> att.verse.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <verse> -> att.verse.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <verse> -> att.verse.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <verse> -> att.verse.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <verse> -> att.verse.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <verse> -> att.verse.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <verse> -> att.verse.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <verse> -> att.verse.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <verse> -> att.verse.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <verse> -> att.verse.vis -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Specifies the symbol used to group lyrics.
      *
      * <verse> -> att.verse.vis -> att.voltaGroupingSym -> att.voltaGroupingSym.attribute.voltasym -> @voltasym
      */
    `@voltasym`: scala.Option[java.lang.String] = scala.None,
    /** Provides a number-like designation that indicates an element’s position in a sequence of similar elements. May not contain space characters.
      *
      * <verse> -> att.nNumberLike -> att.nNumberLike.attribute.n -> @n
      */
    `@n`: scala.Option[DataWORD] = scala.None,
)

/** <volta>
  *
  * Sung text for a specific iteration of a repeated section of music.
  */
case class Volta(
    /** <volta> -> dir -> <dir> (-> Dir)
      * <volta> -> dynam -> <dynam> (-> Dynam)
      * <volta> -> model.lbLike -> lb -> <lb> (-> Lb)
      * <volta> -> space -> <space> (-> Space)
      * <volta> -> model.sylLike -> syl -> <syl> (-> Syl)
      * <volta> -> tempo -> <tempo> (-> Tempo)
      */
    elements: scala.List[Dir | Dynam | Lb | Space | Syl | Tempo] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <volta> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <volta> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <volta> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <volta> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <volta> -> att.volta.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Contains the name of a font-family.
      *
      * <volta> -> att.volta.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <volta> -> att.volta.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <volta> -> att.volta.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <volta> -> att.volta.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <volta> -> att.volta.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <volta> -> att.volta.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <volta> -> att.volta.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <volta> -> att.volta.vis -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <instrDef>
  *
  * (instrument definition) MIDI instrument declaration.
  */
case class InstrDef(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <instrDef> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <instrDef> -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Provides a numeric designation that indicates an element’s position in a sequence of similar elements. Its value must be a non-negative integer.
      *
      * <instrDef> -> att.nInteger -> att.nInteger.attribute.n -> @n
      */
    `@n`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <instrDef> -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Records a MIDI channel value.
      *
      * <instrDef> -> att.instrDef.ges -> att.channelized -> att.channelized.attribute.midi.channel -> @midi.channel
      */
    `@midi.channel`: scala.Option[DataMIDICHANNEL] = scala.None,
    /** Specifies the 'on' part of the duty cycle as a percentage of a note’s duration.
      *
      * <instrDef> -> att.instrDef.ges -> att.channelized -> att.channelized.attribute.midi.duty -> @midi.duty
      */
    `@midi.duty`: scala.Option[DataPERCENTLIMITED] = scala.None,
    /** Sets the MIDI port value.
      *
      * <instrDef> -> att.instrDef.ges -> att.channelized -> att.channelized.attribute.midi.port -> @midi.port
      */
    `@midi.port`: scala.Option[DataMIDIVALUENAME] = scala.None,
    /** Sets the MIDI track.
      *
      * <instrDef> -> att.instrDef.ges -> att.channelized -> att.channelized.attribute.midi.track -> @midi.track
      */
    `@midi.track`: scala.Option[java.lang.String] = scala.None,
    /** Captures the General MIDI instrument number. Use an integer for a 0-based value.
      *
      * <instrDef> -> att.instrDef.ges -> att.midiInstrument -> att.midiInstrument.attribute.midi.instrnum -> @midi.instrnum
      */
    `@midi.instrnum`: scala.Option[DataMIDIVALUE] = scala.None,
    /** Provides a General MIDI label for the MIDI instrument.
      *
      * <instrDef> -> att.instrDef.ges -> att.midiInstrument -> att.midiInstrument.attribute.midi.instrname -> @midi.instrname
      */
    `@midi.instrname`: scala.Option[DataMIDINAMES] = scala.None,
    /** Sets the instrument’s position in a stereo field. MIDI values of 0 and 1 both pan left, 127 or 128 pans right, and 63 or 64 pans to the center. Positve percentage values pan to the right, negative ones to the left. 0% is centered.
      *
      * <instrDef> -> att.instrDef.ges -> att.midiInstrument -> att.midiInstrument.attribute.midi.pan -> @midi.pan
      */
    `@midi.pan`: scala.Option[DataMIDIVALUEPAN] = scala.None,
    /** Records a non-General MIDI patch/instrument name.
      *
      * <instrDef> -> att.instrDef.ges -> att.midiInstrument -> att.midiInstrument.attribute.midi.patchname -> @midi.patchname
      */
    `@midi.patchname`: scala.Option[java.lang.String] = scala.None,
    /** Records a non-General MIDI patch/instrument number.
      *
      * <instrDef> -> att.instrDef.ges -> att.midiInstrument -> att.midiInstrument.attribute.midi.patchnum -> @midi.patchnum
      */
    `@midi.patchnum`: scala.Option[DataMIDIVALUE] = scala.None,
    /** Sets the instrument’s volume.
      *
      * <instrDef> -> att.instrDef.ges -> att.midiInstrument -> att.midiInstrument.attribute.midi.volume -> @midi.volume
      */
    `@midi.volume`: scala.Option[DataMIDIVALUEPERCENT] = scala.None,
    /** The lateral or left-to-right plane.
      *
      * <instrDef> -> att.instrDef.ges -> att.soundLocation -> att.soundLocation.attribute.azimuth -> @azimuth
      */
    `@azimuth`: scala.Option[DataDEGREES] = scala.None,
    /** The above-to-below axis.
      *
      * <instrDef> -> att.instrDef.ges -> att.soundLocation -> att.soundLocation.attribute.elevation -> @elevation
      */
    `@elevation`: scala.Option[DataDEGREES] = scala.None,
)

/** model.addressPart
  */
type ModelAddressPart = java.lang.String

/** model.addressPart_alternation
  */
type ModelAddressPartAlternation = java.lang.String

/** model.addressPart_sequence
  */
type ModelAddressPartSequence = java.lang.String

/** model.addressPart_sequenceOptional
  */
type ModelAddressPartSequenceOptional = java.lang.String

/** model.addressPart_sequenceOptionalRepeatable
  */
type ModelAddressPartSequenceOptionalRepeatable = java.lang.String

/** model.addressPart_sequenceRepeatable
  */
type ModelAddressPartSequenceRepeatable = java.lang.String

/** model.geogNamePart_sequence
  */
type ModelGeogNamePartSequence = java.lang.String

/** model.geogNamePart_sequenceOptional
  */
type ModelGeogNamePartSequenceOptional = java.lang.String

/** model.geogNamePart_sequenceOptionalRepeatable
  */
type ModelGeogNamePartSequenceOptionalRepeatable = java.lang.String

/** model.nameLike.geogName_sequence
  */
type ModelNameLikeGeogNameSequence = java.lang.String

/** model.nameLike.geogName_sequenceOptional
  */
type ModelNameLikeGeogNameSequenceOptional = java.lang.String

/** model.nameLike.geogName_sequenceOptionalRepeatable
  */
type ModelNameLikeGeogNameSequenceOptionalRepeatable = java.lang.String

/** model.nameLike.label_sequence
  */
type ModelNameLikeLabelSequence = java.lang.String

/** model.nameLike.label_sequenceOptional
  */
type ModelNameLikeLabelSequenceOptional = java.lang.String

/** model.nameLike.label_sequenceOptionalRepeatable
  */
type ModelNameLikeLabelSequenceOptionalRepeatable = java.lang.String

/** model.nameLike.place
  */
type ModelNameLikePlace = java.lang.String

/** model.nameLike.place_alternation
  */
type ModelNameLikePlaceAlternation = java.lang.String

/** model.nameLike.place_sequence
  */
type ModelNameLikePlaceSequence = java.lang.String

/** model.nameLike.place_sequenceOptional
  */
type ModelNameLikePlaceSequenceOptional = java.lang.String

/** model.nameLike.place_sequenceOptionalRepeatable
  */
type ModelNameLikePlaceSequenceOptionalRepeatable = java.lang.String

/** model.nameLike.place_sequenceRepeatable
  */
type ModelNameLikePlaceSequenceRepeatable = java.lang.String

/** <persName>
  *
  * (personal name) Designation for an individual, including any or all of that individual's forenames, surnames, honorific titles, and added names.
  */
case class PersName(
    /** <persName> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <persName> -> model.textPhraseLike -> model.pbLike -> pb -> <pb> (-> Pb)
      * <persName> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <persName> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <persName> -> model.textPhraseLike -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <persName> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <persName> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | Pb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <persName> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <persName> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <persName> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <persName> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Contains the end point of a date range in standard ISO form.
      *
      * <persName> -> att.name -> att.datable -> att.datable.attribute.enddate -> @enddate
      */
    `@enddate`: scala.Option[DataISODATE] = scala.None,
    /** Provides the value of a textual date in standard ISO form.
      *
      * <persName> -> att.name -> att.datable -> att.datable.attribute.isodate -> @isodate
      */
    `@isodate`: scala.Option[DataISODATE] = scala.None,
    /** Contains an upper boundary for an uncertain date in standard ISO form.
      *
      * <persName> -> att.name -> att.datable -> att.datable.attribute.notafter -> @notafter
      */
    `@notafter`: scala.Option[DataISODATE] = scala.None,
    /** Contains a lower boundary, in standard ISO form, for an uncertain date.
      *
      * <persName> -> att.name -> att.datable -> att.datable.attribute.notbefore -> @notbefore
      */
    `@notbefore`: scala.Option[DataISODATE] = scala.None,
    /** Contains the starting point of a date range in standard ISO form.
      *
      * <persName> -> att.name -> att.datable -> att.datable.attribute.startdate -> @startdate
      */
    `@startdate`: scala.Option[DataISODATE] = scala.None,
    /** Used to record a pointer to the regularized form of the name elsewhere in the document.
      *
      * <persName> -> att.name -> att.name.attribute.nymref -> @nymref
      */
    `@nymref`: scala.Option[DataURI] = scala.None,
    /** Used to specify further information about the entity referenced by this name, for example, the occupation of a person or the status of a place.
      *
      * <persName> -> att.name -> att.name.attribute.role -> @role
      */
    `@role`: scala.Option[java.lang.String] = scala.None,
)

/** model.addressLike_sequence
  */
type ModelAddressLikeSequence = java.lang.String

/** model.addressLike_sequenceOptional
  */
type ModelAddressLikeSequenceOptional = java.lang.String

/** model.addressLike_sequenceOptionalRepeatable
  */
type ModelAddressLikeSequenceOptionalRepeatable = java.lang.String

/** model.annotLike_sequence
  */
type ModelAnnotLikeSequence = java.lang.String

/** model.annotLike_sequenceOptional
  */
type ModelAnnotLikeSequenceOptional = java.lang.String

/** model.annotLike_sequenceOptionalRepeatable
  */
type ModelAnnotLikeSequenceOptionalRepeatable = java.lang.String

/** model.biblLike_sequence
  */
type ModelBiblLikeSequence = java.lang.String

/** model.biblLike_sequenceOptional
  */
type ModelBiblLikeSequenceOptional = java.lang.String

/** model.biblLike_sequenceOptionalRepeatable
  */
type ModelBiblLikeSequenceOptionalRepeatable = java.lang.String

/** model.dateLike_sequence
  */
type ModelDateLikeSequence = java.lang.String

/** model.dateLike_sequenceOptional
  */
type ModelDateLikeSequenceOptional = java.lang.String

/** model.dateLike_sequenceOptionalRepeatable
  */
type ModelDateLikeSequenceOptionalRepeatable = java.lang.String

/** model.dimLike_sequence
  */
type ModelDimLikeSequence = java.lang.String

/** model.dimLike_sequenceOptional
  */
type ModelDimLikeSequenceOptional = java.lang.String

/** model.dimLike_sequenceOptionalRepeatable
  */
type ModelDimLikeSequenceOptionalRepeatable = java.lang.String

/** model.editorialLike_sequence
  */
type ModelEditorialLikeSequence = java.lang.String

/** model.editorialLike_sequenceOptional
  */
type ModelEditorialLikeSequenceOptional = java.lang.String

/** model.editorialLike_sequenceOptionalRepeatable
  */
type ModelEditorialLikeSequenceOptionalRepeatable = java.lang.String

/** model.identifierLike_sequence
  */
type ModelIdentifierLikeSequence = java.lang.String

/** model.identifierLike_sequenceOptional
  */
type ModelIdentifierLikeSequenceOptional = java.lang.String

/** model.identifierLike_sequenceOptionalRepeatable
  */
type ModelIdentifierLikeSequenceOptionalRepeatable = java.lang.String

/** model.keySigLike_sequence
  */
type ModelKeySigLikeSequence = java.lang.String

/** model.keySigLike_sequenceOptional
  */
type ModelKeySigLikeSequenceOptional = java.lang.String

/** model.keySigLike_sequenceOptionalRepeatable
  */
type ModelKeySigLikeSequenceOptionalRepeatable = java.lang.String

/** model.measurementLike
  */
type ModelMeasurementLike = java.lang.String

/** model.measurementLike_alternation
  */
type ModelMeasurementLikeAlternation = java.lang.String

/** model.measurementLike_sequence
  */
type ModelMeasurementLikeSequence = java.lang.String

/** model.measurementLike_sequenceOptional
  */
type ModelMeasurementLikeSequenceOptional = java.lang.String

/** model.measurementLike_sequenceOptionalRepeatable
  */
type ModelMeasurementLikeSequenceOptionalRepeatable = java.lang.String

/** model.measurementLike_sequenceRepeatable
  */
type ModelMeasurementLikeSequenceRepeatable = java.lang.String

/** model.meterSigLike_sequence
  */
type ModelMeterSigLikeSequence = java.lang.String

/** model.meterSigLike_sequenceOptional
  */
type ModelMeterSigLikeSequenceOptional = java.lang.String

/** model.meterSigLike_sequenceOptionalRepeatable
  */
type ModelMeterSigLikeSequenceOptionalRepeatable = java.lang.String

/** model.numLike_sequence
  */
type ModelNumLikeSequence = java.lang.String

/** model.numLike_sequenceOptional
  */
type ModelNumLikeSequenceOptional = java.lang.String

/** model.numLike_sequenceOptionalRepeatable
  */
type ModelNumLikeSequenceOptionalRepeatable = java.lang.String

/** model.relationLike_sequence
  */
type ModelRelationLikeSequence = java.lang.String

/** model.relationLike_sequenceOptional
  */
type ModelRelationLikeSequenceOptional = java.lang.String

/** model.relationLike_sequenceOptionalRepeatable
  */
type ModelRelationLikeSequenceOptionalRepeatable = java.lang.String

/** model.repositoryLike_sequence
  */
type ModelRepositoryLikeSequence = java.lang.String

/** model.repositoryLike_sequenceOptional
  */
type ModelRepositoryLikeSequenceOptional = java.lang.String

/** model.repositoryLike_sequenceOptionalRepeatable
  */
type ModelRepositoryLikeSequenceOptionalRepeatable = java.lang.String

/** model.textComponentLike
  */
type ModelTextComponentLike = java.lang.String

/** <accid>
  *
  * (accidental) Records a temporary alteration to the pitch of a note.
  */
case class Accid(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <accid> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <accid> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <accid> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Records the performed pitch inflection.
      *
      * <accid> -> att.accid.ges -> att.accidental.ges -> att.accidental.ges.attribute.accid.ges -> @accid.ges
      */
    `@accid.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** Captures a written accidental.
      *
      * <accid> -> att.accid.log -> att.accidental -> att.accidental.attribute.accid -> @accid
      */
    `@accid`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <accid> -> att.accid.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <accid> -> att.accid.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <accid> -> att.accid.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <accid> -> att.accid.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Records the function of an accidental.
      *
      * <accid> -> att.accid.log -> att.accid.log.attribute.func -> @func
      */
    `@func`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <accid> -> att.accid.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <accid> -> att.accid.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <accid> -> att.accid.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <accid> -> att.accid.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <accid> -> att.accid.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <accid> -> att.accid.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <accid> -> att.accid.vis -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <accid> -> att.accid.vis -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <arranger>
  *
  * A person or organization who transcribes a musical composition, usually for a different medium from that of the original; in an arrangement the musical substance remains essentially unchanged.
  */
case class Arranger(
    /** <arranger> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <arranger> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <arranger> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <arranger> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <arranger> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <arranger> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <arranger> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <arranger> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <arranger> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <arranger> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
)

/** <artic>
  *
  * (articulation) An indication of how to play a note or chord.
  */
case class Artic(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <artic> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <artic> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <artic> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Encodes the written articulation(s). Articulations are normally encoded in order from the note head outward; that is, away from the stem. See additional notes at att.vis.note. Only articulations should be encoded in the artic attribute; for example, fingerings should be encoded using the <fing> element.
      *
      * <artic> -> att.artic.log -> att.articulation -> att.articulation.attribute.artic -> @artic
      */
    `@artic`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <artic> -> att.artic.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <artic> -> att.artic.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <artic> -> att.artic.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <artic> -> att.artic.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <artic> -> att.artic.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <artic> -> att.artic.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <artic> -> att.artic.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <artic> -> att.artic.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <artic> -> att.artic.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <artic> -> att.artic.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Captures the placement of the item with respect to the event with which it is associated.
      *
      * <artic> -> att.artic.vis -> att.placementRelEvent -> att.placementRelEvent.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <artic> -> att.artic.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <artic> -> att.artic.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <body>
  *
  * Contains the whole of a single musical text, excluding any front or back matter.
  */
case class Body(
    /** <body> -> model.mdivLike -> mdiv -> <mdiv> (-> Mdiv)
      */
    elements: scala.List[Mdiv] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <body> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <body> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <body> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <caesura>
  *
  * Break, pause, or interruption in the normal tempo of a composition. Typically indicated by "railroad tracks", i.e., two diagonal slashes.
  */
case class Caesura(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <caesura> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <caesura> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <caesura> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <caesura> -> att.caesura.log -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <caesura> -> att.caesura.log -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <caesura> -> att.caesura.log -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <caesura> -> att.caesura.log -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <caesura> -> att.caesura.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <caesura> -> att.caesura.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <caesura> -> att.caesura.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <caesura> -> att.caesura.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <caesura> -> att.caesura.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <caesura> -> att.caesura.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <caesura> -> att.caesura.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <chord>
  *
  * A simultaneous sounding of two or more notes in the same layer *with the same duration*.
  */
case class Chord(
    /** <chord> -> model.chordPart -> artic -> <artic> (-> Artic)
      * <chord> -> model.chordPart -> note -> <note> (-> Note)
      * <chord> -> model.verseLike -> refrain -> <refrain> (-> Refrain)
      * <chord> -> model.sylLike -> syl -> <syl> (-> Syl)
      * <chord> -> model.verseLike -> verse -> <verse> (-> Verse)
      */
    elements: scala.List[Artic | Note | Refrain | Syl | Verse] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <chord> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <chord> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <chord> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Provides a way of pointing to a MIDI instrument definition. It must contain the ID of an <instrDef> element elsewhere in the document.
      *
      * <chord> -> att.chord.ges -> att.instrumentIdent -> att.instrumentIdent.attribute.instr -> @instr
      */
    `@instr`: scala.Option[DataURI] = scala.None,
    /** Records the number of augmentation dots required by a written dotted duration.
      *
      * <chord> -> att.chord.log -> att.augmentDots -> att.augmentDots.attribute.dots -> @dots
      */
    `@dots`: scala.Option[DataAUGMENTDOT] = scala.None,
    /** Marks a note or chord as a "grace" (without a definite performed duration) and records from which other note/chord it should "steal" time.
      *
      * <chord> -> att.chord.log -> att.chord.log.cmn -> att.graced -> att.graced.attribute.grace -> @grace
      */
    `@grace`: scala.Option[DataGRACE] = scala.None,
    /** Records the amount of time to be "stolen" from a non-grace note/chord.
      *
      * <chord> -> att.chord.log -> att.chord.log.cmn -> att.graced -> att.graced.attribute.grace.time -> @grace.time
      */
    `@grace.time`: scala.Option[DataPERCENT] = scala.None,
    /** <chord> -> att.chord.log -> att.cue -> att.cue.attribute.cue -> @cue
      */
    `@cue`: scala.Option[DataBOOLEAN] = scala.None,
    /** (duration) Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
      *
      * <chord> -> att.chord.log -> att.duration.log -> att.duration.log.attribute.dur -> @dur
      */
    `@dur`: scala.Option[DataDURATION] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <chord> -> att.chord.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <chord> -> att.chord.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <chord> -> att.chord.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <chord> -> att.chord.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <chord> -> att.chord.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <chord> -> att.chord.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <chord> -> att.chord.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <chord> -> att.chord.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Describes the direction of a stem.
      *
      * <chord> -> att.chord.vis -> att.stems -> att.stems.attribute.stem.dir -> @stem.dir
      */
    `@stem.dir`: scala.Option[DataSTEMDIRECTION] = scala.None,
    /** Encodes the stem length.
      *
      * <chord> -> att.chord.vis -> att.stems -> att.stems.attribute.stem.len -> @stem.len
      */
    `@stem.len`: scala.Option[DataMEASUREMENTUNSIGNED] = scala.None,
    /** Encodes any stem "modifiers"; that is, symbols rendered on the stem, such as tremolo or Sprechstimme indicators.
      *
      * <chord> -> att.chord.vis -> att.stems -> att.stems.attribute.stem.mod -> @stem.mod
      */
    `@stem.mod`: scala.Option[DataSTEMMODIFIER] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <chord> -> att.chord.vis -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Presence of this attribute indicates that the secondary beam should be broken following this note/chord. The value of the attribute records the number of beams which should remain unbroken.
      *
      * <chord> -> att.chord.vis -> att.chord.vis.cmn -> att.beamSecondary -> att.beamSecondary.attribute.breaksec -> @breaksec
      */
    `@breaksec`: scala.Option[java.lang.String] = scala.None,
    /** Indicates a single, alternative note head should be displayed instead of individual note heads. The highest and lowest notes of the chord usually indicate the upper and lower boundaries of the cluster note head.
      *
      * <chord> -> att.chord.vis -> att.chord.vis.attribute.cluster -> @cluster
      */
    `@cluster`: scala.Option[DataCLUSTER] = scala.None,
)

/** <clef>
  *
  * Indication of the exact location of a particular note on the staff and, therefore, the other notes as well.
  */
case class Clef(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <clef> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <clef> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <clef> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <clef> -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <clef> -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Describes a clef’s shape.
      *
      * <clef> -> att.clef.log -> att.clefShape -> att.clefShape.attribute.shape -> @shape
      */
    `@shape`: scala.Option[DataCLEFSHAPE] = scala.None,
    /** Indicates the line upon which a feature stands. The value must be in the range between 1 and the number of lines on the staff. The numbering of lines starts with the lowest line of the staff.
      *
      * <clef> -> att.clef.log -> att.lineLoc -> att.lineLoc.attribute.line -> @line
      */
    `@line`: scala.Option[DataCLEFLINE] = scala.None,
    /** (octave) Captures written octave information.
      *
      * <clef> -> att.clef.log -> att.octave -> att.octave.attribute.oct -> @oct
      */
    `@oct`: scala.Option[DataOCTAVE] = scala.None,
    /** Records the amount of octave displacement.
      *
      * <clef> -> att.clef.log -> att.octaveDisplacement -> att.octaveDisplacement.attribute.dis -> @dis
      */
    `@dis`: scala.Option[DataOCTAVEDIS] = scala.None,
    /** Records the direction of octave displacement.
      *
      * <clef> -> att.clef.log -> att.octaveDisplacement -> att.octaveDisplacement.attribute.dis.place -> @dis.place
      */
    `@dis.place`: scala.Option[DataSTAFFRELBasic] = scala.None,
    /** Records the function of the clef. A "cautionary" clef does not change the following pitches.
      *
      * <clef> -> att.clef.log -> att.clef.log.attribute.cautionary -> @cautionary
      */
    `@cautionary`: scala.Option[DataBOOLEAN] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <clef> -> att.clef.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <clef> -> att.clef.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <clef> -> att.clef.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <clef> -> att.clef.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <clef> -> att.clef.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <clef> -> att.clef.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Contains the name of a font-family.
      *
      * <clef> -> att.clef.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <clef> -> att.clef.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <clef> -> att.clef.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <clef> -> att.clef.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <clef> -> att.clef.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <clef> -> att.clef.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <clef> -> att.clef.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <clef> -> att.clef.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <clef> -> att.clef.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <clefGrp>
  *
  * (clef group) A set of simultaneously-occurring clefs.
  */
case class ClefGrp(
    /** <clefGrp> -> clef -> <clef> (-> Clef)
      */
    elements: scala.List[Clef] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <clefGrp> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <clefGrp> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <clefGrp> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <clefGrp> -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <clefGrp> -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
)

/** <composer>
  *
  * The name of the creator of the intellectual content of a musical work.
  */
case class Composer(
    /** <composer> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <composer> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <composer> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <composer> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <composer> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <composer> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <composer> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <composer> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <composer> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <composer> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
)

/** <date>
  *
  * A string identifying a point in time or the time period between two such points.
  */
case class Date(
    /** <date> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <date> -> model.textPhraseLike -> model.pbLike -> pb -> <pb> (-> Pb)
      * <date> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <date> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <date> -> model.textPhraseLike -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <date> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <date> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | Pb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <date> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <date> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <date> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Indicates the calendar system to which a date belongs, for example, Gregorian, Julian, Roman, Mosaic, Revolutionary, Islamic, etc.
      *
      * <date> -> att.calendared -> att.calendared.attribute.calendar -> @calendar
      */
    `@calendar`: scala.Option[java.lang.String] = scala.None,
    /** Contains the end point of a date range in standard ISO form.
      *
      * <date> -> att.datable -> att.datable.attribute.enddate -> @enddate
      */
    `@enddate`: scala.Option[DataISODATE] = scala.None,
    /** Provides the value of a textual date in standard ISO form.
      *
      * <date> -> att.datable -> att.datable.attribute.isodate -> @isodate
      */
    `@isodate`: scala.Option[DataISODATE] = scala.None,
    /** Contains an upper boundary for an uncertain date in standard ISO form.
      *
      * <date> -> att.datable -> att.datable.attribute.notafter -> @notafter
      */
    `@notafter`: scala.Option[DataISODATE] = scala.None,
    /** Contains a lower boundary, in standard ISO form, for an uncertain date.
      *
      * <date> -> att.datable -> att.datable.attribute.notbefore -> @notbefore
      */
    `@notbefore`: scala.Option[DataISODATE] = scala.None,
    /** Contains the starting point of a date range in standard ISO form.
      *
      * <date> -> att.datable -> att.datable.attribute.startdate -> @startdate
      */
    `@startdate`: scala.Option[DataISODATE] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <date> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
)

/** <dir>
  *
  * (directive) An instruction expressed as a combination of text and symbols, typically above, below, or between staves, but not on the staff — that is not encoded elsewhere in more specific elements, like <tempo>, <dynam> or <repeatMark>.
  */
case class Dir(
    /** <dir> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <dir> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <dir> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <dir> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <dir> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <dir> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <dir> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <dir> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <dir> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <dir> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <dir> -> att.dir.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <dir> -> att.dir.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <dir> -> att.dir.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <dir> -> att.dir.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <dir> -> att.dir.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <dir> -> att.dir.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <dir> -> att.dir.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <dir> -> att.dir.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <dir> -> att.dir.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes the style of a line.
      *
      * <dir> -> att.dir.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <dir> -> att.dir.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <dir> -> att.dir.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <dir> -> att.dir.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <dir> -> att.dir.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <dir> -> att.dir.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <dir> -> att.dir.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Indicates the presence of an extension symbol, typically a line.
      *
      * <dir> -> att.dir.vis -> att.extender -> att.extender.attribute.extender -> @extender
      */
    `@extender`: scala.Option[DataBOOLEAN] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <dir> -> att.dir.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <dir> -> att.dir.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <dir> -> att.dir.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <dir> -> att.dir.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <dir> -> att.dir.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <dynam>
  *
  * (dynamic) Indication of the volume of a note, phrase, or section of music.
  */
case class Dynam(
    /** <dynam> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <dynam> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <dynam> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <dynam> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <dynam> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <dynam> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <dynam> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <dynam> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <dynam> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <dynam> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <dynam> -> att.dynam.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <dynam> -> att.dynam.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <dynam> -> att.dynam.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <dynam> -> att.dynam.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <dynam> -> att.dynam.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <dynam> -> att.dynam.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <dynam> -> att.dynam.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <dynam> -> att.dynam.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <dynam> -> att.dynam.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes the style of a line.
      *
      * <dynam> -> att.dynam.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <dynam> -> att.dynam.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <dynam> -> att.dynam.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <dynam> -> att.dynam.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <dynam> -> att.dynam.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <dynam> -> att.dynam.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <dynam> -> att.dynam.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Indicates the presence of an extension symbol, typically a line.
      *
      * <dynam> -> att.dynam.vis -> att.extender -> att.extender.attribute.extender -> @extender
      */
    `@extender`: scala.Option[DataBOOLEAN] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <dynam> -> att.dynam.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <dynam> -> att.dynam.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <dynam> -> att.dynam.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <dynam> -> att.dynam.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <dynam> -> att.dynam.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <ending>
  *
  * Alternative ending for a repeated passage of music; i.e., prima volta, seconda volta, etc.
  */
case class Ending(
    /** <ending> -> model.sectionPart.cmn -> model.measureLike -> measure -> <measure> (-> Measure)
      * <ending> -> model.milestoneLike.music -> model.pbLike -> pb -> <pb> (-> Pb)
      * <ending> -> model.milestoneLike.music -> sb -> <sb> (-> Sb)
      * <ending> -> model.scoreDefLike -> scoreDef -> <scoreDef> (-> ScoreDef)
      * <ending> -> model.sectionLike -> section -> <section> (-> Section)
      * <ending> -> model.staffDefLike -> staffDef -> <staffDef> (-> StaffDef)
      */
    elements: scala.List[Measure | Pb | Sb | ScoreDef | Section | StaffDef] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <ending> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <ending> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <ending> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Describes the style of a line.
      *
      * <ending> -> att.ending.vis -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <ending> -> att.ending.vis -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <ending> -> att.ending.vis -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <ending> -> att.ending.vis -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <ending> -> att.ending.vis -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <ending> -> att.ending.vis -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <ending> -> att.ending.vis -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
)

/** <label>
  *
  * A container for document text that identifies the feature to which it is attached. For a "tool tip" or other generated label, use the @label attribute.
  */
case class Label(
    /** <label> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <label> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <label> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <label> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <label> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <label> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <label> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <label> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <label> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <label> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
)

/** <labelAbbr>
  *
  * A label on the pages following the first.
  */
case class LabelAbbr(
    /** <labelAbbr> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <labelAbbr> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <labelAbbr> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <labelAbbr> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <labelAbbr> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <labelAbbr> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <labelAbbr> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <labelAbbr> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <labelAbbr> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <labelAbbr> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
)

/** <layer>
  *
  * An independent stream of events on a staff.
  */
case class Layer(
    /** <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.cmn -> bTrem -> <bTrem> (-> BTrem)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.cmn -> beam -> <beam> (-> Beam)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.cmn -> beatRpt -> <beatRpt> (-> BeatRpt)
      * <layer> -> model.layerPart -> model.eventLike -> chord -> <chord> (-> Chord)
      * <layer> -> model.layerPart -> model.eventLike -> clef -> <clef> (-> Clef)
      * <layer> -> model.layerPart -> model.eventLike -> clefGrp -> <clefGrp> (-> ClefGrp)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.cmn -> fTrem -> <fTrem> (-> FTrem)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.cmn -> graceGrp -> <graceGrp> (-> GraceGrp)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.cmn -> halfmRpt -> <halfmRpt> (-> HalfmRpt)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.measureFilling -> mRest -> <mRest> (-> MRest)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.measureFilling -> mRpt -> <mRpt> (-> MRpt)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.measureFilling -> multiRest -> <multiRest> (-> MultiRest)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.measureFilling -> multiRpt -> <multiRpt> (-> MultiRpt)
      * <layer> -> model.layerPart -> model.eventLike -> note -> <note> (-> Note)
      * <layer> -> model.milestoneLike.music -> model.pbLike -> pb -> <pb> (-> Pb)
      * <layer> -> model.layerPart -> model.eventLike -> rest -> <rest> (-> Rest)
      * <layer> -> model.milestoneLike.music -> sb -> <sb> (-> Sb)
      * <layer> -> model.layerPart -> model.eventLike -> space -> <space> (-> Space)
      * <layer> -> model.layerPart -> model.eventLike -> tabGrp -> <tabGrp> (-> TabGrp)
      * <layer> -> model.layerPart -> model.layerPart.cmn -> model.eventLike.cmn -> tuplet -> <tuplet> (-> Tuplet)
      */
    elements: scala.List[
      BTrem | Beam | BeatRpt | Chord | Clef | ClefGrp | FTrem | GraceGrp | HalfmRpt | MRest | MRpt | MultiRest |
        MultiRpt | Note | Pb | Rest | Sb | Space | TabGrp | Tuplet,
    ] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <layer> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <layer> -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Provides a numeric designation that indicates an element’s position in a sequence of similar elements. Its value must be a non-negative integer.
      *
      * <layer> -> att.nInteger -> att.nInteger.attribute.n -> @n
      */
    `@n`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <layer> -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <lb>
  *
  * (line beginning) An empty formatting element that forces text to begin on a new line.
  */
case class Lb(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <lb> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <lb> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <lb> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <lyricist>
  *
  * Person or organization who is a writer of the text of a song.
  */
case class Lyricist(
    /** <lyricist> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <lyricist> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <lyricist> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <lyricist> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <lyricist> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <lyricist> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <lyricist> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <lyricist> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <lyricist> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <lyricist> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
)

/** <mdiv>
  *
  * (musical division) (musical division) – Contains a subdivision of the body of a musical text.
  */
case class Mdiv(
    /** <mdiv> -> model.mdivLike -> mdiv -> <mdiv> (-> Mdiv)
      * <mdiv> -> model.scoreLike -> score -> <score> (-> Score)
      */
    elements: scala.List[Mdiv | Score] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <mdiv> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <mdiv> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <mdiv> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Indicates that the performance of the next musical division should begin immediately following this one.
      *
      * <mdiv> -> att.mdiv.ges -> att.attacking -> att.attacking.attribute.attacca -> @attacca
      */
    `@attacca`: scala.Option[DataBOOLEAN] = scala.None,
    /** Provides a number-like designation that indicates an element's position in a sequence of similar elements. May not contain space characters.
      *
      * <mdiv> -> @n
      */
    `@n`: scala.Option[DataWORD] = scala.None,
)

/** <mei>
  *
  * Contains a single MEI-conformant document, consisting of an MEI header and a musical text, either in isolation or as part of an meiCorpus element.
  */
case class Mei(
    /** <mei> -> meiHead -> <meiHead> (-> MeiHead)
      * <mei> -> music -> <music> (-> Music)
      */
    elements: scala.List[MeiHead | Music] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <mei> -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Specifies a generic MEI version label.
      *
      * <mei> -> att.meiVersion -> att.meiVersion.attribute.meiversion -> @meiversion
      */
    `@meiversion`: java.lang.String,
)

/** <music>
  *
  * Contains a single musical text of any kind, whether unitary or composite, for example, an etude, opera, song cycle, symphony, or anthology of piano solos.
  */
case class Music(
    /** <music> -> macro.musicPart -> body -> <body> (-> Body)
      */
    elements: scala.List[Body] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <music> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <music> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <music> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <note>
  *
  * A single pitched event.
  */
case class Note(
    /** <note> -> model.noteModifierLike -> accid -> <accid> (-> Accid)
      * <note> -> model.noteModifierLike -> artic -> <artic> (-> Artic)
      * <note> -> model.verseLike -> refrain -> <refrain> (-> Refrain)
      * <note> -> model.sylLike -> syl -> <syl> (-> Syl)
      * <note> -> model.verseLike -> verse -> <verse> (-> Verse)
      */
    elements: scala.List[Accid | Artic | Refrain | Syl | Verse] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <note> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <note> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <note> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Provides a way of pointing to a MIDI instrument definition. It must contain the ID of an <instrDef> element elsewhere in the document.
      *
      * <note> -> att.note.ges -> att.instrumentIdent -> att.instrumentIdent.attribute.instr -> @instr
      */
    `@instr`: scala.Option[DataURI] = scala.None,
    /** MIDI Note-on/off velocity.
      *
      * <note> -> att.note.ges -> att.midiVelocity -> att.midiVelocity.attribute.vel -> @vel
      */
    `@vel`: scala.Option[DataMIDIVALUE] = scala.None,
    /** This attribute is deprecated and will be removed in a future version. Indicates which finger, if any, should be used to play an individual string. The index, middle, ring, and little fingers are represented by the values 1-4, while t is for the thumb. The values x and o indicate muffled and open strings, respectively.
      *
      * <note> -> att.note.ges -> att.stringtab -> att.stringtab.attribute.tab.fing -> @tab.fing
      */
    `@tab.fing`: scala.Option[DataFINGERFRET] = scala.None,
    /** Records the location at which a string should be stopped against a fret.
      *
      * <note> -> att.note.ges -> att.stringtab -> att.stringtab.attribute.tab.fret -> @tab.fret
      */
    `@tab.fret`: scala.Option[DataFRETNUMBER] = scala.None,
    /** Used in German lute tablature in cases where vertical positioning deviates from the norm which can be specified by @tab.align. Indicates the position of the tab note on one of the horizontal strands corresponding to the @lines attribute on <staffDef>. (Note that in this case, the lines are conceptual rather than visible).
      *
      * <note> -> att.note.ges -> att.stringtab -> att.stringtab.attribute.tab.line -> @tab.line
      */
    `@tab.line`: scala.Option[DataCLEFLINE] = scala.None,
    /** This attribute is deprecated in favor of @tab.course and will be removed in a future version. Records which string is to be played.
      *
      * <note> -> att.note.ges -> att.stringtab -> att.stringtab.attribute.tab.string -> @tab.string
      */
    `@tab.string`: scala.Option[DataSTRINGNUMBER] = scala.None,
    /** Records which course is to be played.
      *
      * <note> -> att.note.ges -> att.stringtab -> att.stringtab.attribute.tab.course -> @tab.course
      */
    `@tab.course`: scala.Option[DataCOURSENUMBER] = scala.None,
    /** Records performed octave information that differs from the written value.
      *
      * <note> -> att.note.ges -> att.note.ges.attribute.oct.ges -> @oct.ges
      */
    `@oct.ges`: scala.Option[DataOCTAVE] = scala.None,
    /** Contains a performed pitch name that differs from the written value.
      *
      * <note> -> att.note.ges -> att.note.ges.attribute.pname.ges -> @pname.ges
      */
    `@pname.ges`: scala.Option[DataPITCHNAMEGESTURAL] = scala.None,
    /** Records the number of augmentation dots required by a written dotted duration.
      *
      * <note> -> att.note.log -> att.augmentDots -> att.augmentDots.attribute.dots -> @dots
      */
    `@dots`: scala.Option[DataAUGMENTDOT] = scala.None,
    /** <note> -> att.note.log -> att.cue -> att.cue.attribute.cue -> @cue
      */
    `@cue`: scala.Option[DataBOOLEAN] = scala.None,
    /** (duration) Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
      *
      * <note> -> att.note.log -> att.duration.log -> att.duration.log.attribute.dur -> @dur
      */
    `@dur`: scala.Option[DataDURATION] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <note> -> att.note.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <note> -> att.note.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Marks a note or chord as a "grace" (without a definite performed duration) and records from which other note/chord it should "steal" time.
      *
      * <note> -> att.note.log -> att.note.log.cmn -> att.graced -> att.graced.attribute.grace -> @grace
      */
    `@grace`: scala.Option[DataGRACE] = scala.None,
    /** Records the amount of time to be "stolen" from a non-grace note/chord.
      *
      * <note> -> att.note.log -> att.note.log.cmn -> att.graced -> att.graced.attribute.grace.time -> @grace.time
      */
    `@grace.time`: scala.Option[DataPERCENT] = scala.None,
    /** (pitch name) Contains a written pitch name.
      *
      * <note> -> att.note.log -> att.pitched -> att.pitch -> att.pitch.attribute.pname -> @pname
      */
    `@pname`: scala.Option[DataPITCHNAME] = scala.None,
    /** (octave) Captures written octave information.
      *
      * <note> -> att.note.log -> att.pitched -> att.octave -> att.octave.attribute.oct -> @oct
      */
    `@oct`: scala.Option[DataOCTAVE] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <note> -> att.note.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <note> -> att.note.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <note> -> att.note.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <note> -> att.note.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <note> -> att.note.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <note> -> att.note.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Describes the direction of a stem.
      *
      * <note> -> att.note.vis -> att.stems -> att.stems.attribute.stem.dir -> @stem.dir
      */
    `@stem.dir`: scala.Option[DataSTEMDIRECTION] = scala.None,
    /** Encodes the stem length.
      *
      * <note> -> att.note.vis -> att.stems -> att.stems.attribute.stem.len -> @stem.len
      */
    `@stem.len`: scala.Option[DataMEASUREMENTUNSIGNED] = scala.None,
    /** Encodes any stem "modifiers"; that is, symbols rendered on the stem, such as tremolo or Sprechstimme indicators.
      *
      * <note> -> att.note.vis -> att.stems -> att.stems.attribute.stem.mod -> @stem.mod
      */
    `@stem.mod`: scala.Option[DataSTEMMODIFIER] = scala.None,
    /** Contains the name of a font-family.
      *
      * <note> -> att.note.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <note> -> att.note.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <note> -> att.note.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <note> -> att.note.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <note> -> att.note.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <note> -> att.note.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <note> -> att.note.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <note> -> att.note.vis -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Presence of this attribute indicates that the secondary beam should be broken following this note/chord. The value of the attribute records the number of beams which should remain unbroken.
      *
      * <note> -> att.note.vis -> att.note.vis.cmn -> att.beamSecondary -> att.beamSecondary.attribute.breaksec -> @breaksec
      */
    `@breaksec`: scala.Option[java.lang.String] = scala.None,
)

/** <ornam>
  *
  * An element indicating an ornament that is not a mordent, turn, or trill.
  */
case class Ornam(
    /** <ornam> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <ornam> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <ornam> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <ornam> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <ornam> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <ornam> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <ornam> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <ornam> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <ornam> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <ornam> -> att.ornam.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <ornam> -> att.ornam.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <ornam> -> att.ornam.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <ornam> -> att.ornam.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (duration) When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
      *
      * <ornam> -> att.ornam.log -> att.duration.additive -> att.duration.additive.attribute.dur -> @dur
      */
    `@dur`: scala.Option[java.lang.String] = scala.None,
    /** Records the sounding accidental associated with an upper neighboring note.
      *
      * <ornam> -> att.ornam.log -> att.ornamentAccid -> att.ornamentAccid.ges -> att.ornamentAccid.ges.attribute.accidupper.ges -> @accidupper.ges
      */
    `@accidupper.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** Records the sounding accidental associated with a lower neighboring note.
      *
      * <ornam> -> att.ornam.log -> att.ornamentAccid -> att.ornamentAccid.ges -> att.ornamentAccid.ges.attribute.accidlower.ges -> @accidlower.ges
      */
    `@accidlower.ges`: scala.Option[DataACCIDENTALGESTURAL] = scala.None,
    /** Records the written accidental associated with an upper neighboring note.
      *
      * <ornam> -> att.ornam.log -> att.ornamentAccid -> att.ornamentAccid.attribute.accidupper -> @accidupper
      */
    `@accidupper`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** Records the written accidental associated with a lower neighboring note.
      *
      * <ornam> -> att.ornam.log -> att.ornamentAccid -> att.ornamentAccid.attribute.accidlower -> @accidlower
      */
    `@accidlower`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <ornam> -> att.ornam.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <ornam> -> att.ornam.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <ornam> -> att.ornam.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <ornam> -> att.ornam.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <ornam> -> att.ornam.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <ornam> -> att.ornam.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <ornam> -> att.ornam.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <ornam> -> att.ornam.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <ornam> -> att.ornam.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <ornam> -> att.ornam.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <pb>
  *
  * (page beginning) An empty formatting element that forces text to begin on a new page.
  */
case class Pb(
    /** <pb> -> macro.metaLike.page -> pgFoot -> <pgFoot> (-> PgFoot)
      * <pb> -> macro.metaLike.page -> pgHead -> <pgHead> (-> PgHead)
      */
    elements: scala.List[PgFoot | PgHead] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <pb> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <pb> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <pb> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** States the side of a leaf (as in a manuscript) on which the content following the <pb> element occurs.
      *
      * <pb> -> att.pb.vis -> att.pb.vis.attribute.folium -> @folium
      */
    `@folium`: scala.Option[java.lang.String] = scala.None,
)

/** <pgFoot>
  *
  * (page footer) A running footer.
  */
case class PgFoot(
    /** <pgFoot> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <pgFoot> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <pgFoot> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <pgFoot> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <pgFoot> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <pgFoot> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <pgFoot> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <pgFoot> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <pgFoot> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Records the function (i.e., placement) of a page header or footer.
      *
      * <pgFoot> -> att.formework -> att.formework.attribute.func -> @func
      */
    `@func`: scala.Option[DataPGFUNC] = scala.None,
    /** Records horizontal alignment.
      *
      * <pgFoot> -> att.horizontalAlign -> att.horizontalAlign.attribute.halign -> @halign
      */
    `@halign`: scala.Option[DataHORIZONTALALIGNMENT] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <pgFoot> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
)

/** <pgHead>
  *
  * (page header) A running header.
  */
case class PgHead(
    /** <pgHead> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <pgHead> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <pgHead> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <pgHead> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <pgHead> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <pgHead> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <pgHead> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <pgHead> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <pgHead> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Records the function (i.e., placement) of a page header or footer.
      *
      * <pgHead> -> att.formework -> att.formework.attribute.func -> @func
      */
    `@func`: scala.Option[DataPGFUNC] = scala.None,
    /** Records horizontal alignment.
      *
      * <pgHead> -> att.horizontalAlign -> att.horizontalAlign.attribute.halign -> @halign
      */
    `@halign`: scala.Option[DataHORIZONTALALIGNMENT] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <pgHead> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
)

/** <pubPlace>
  *
  * (publication place) Name of the place where a bibliographic item was published.
  */
case class PubPlace(
    /** <pubPlace> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <pubPlace> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <pubPlace> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <pubPlace> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <pubPlace> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <pubPlace> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <pubPlace> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <pubPlace> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <pubPlace> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <pubPlace> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
)

/** <rend>
  *
  * (render) A formatting element indicating special visual rendering, e.g., bold or italicized, of a text word or phrase.
  */
case class Rend(
    /** <rend> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <rend> -> model.textPhraseLike -> model.pbLike -> pb -> <pb> (-> Pb)
      * <rend> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <rend> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <rend> -> model.textPhraseLike -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <rend> -> model.textPhraseLike -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <rend> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | Pb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <rend> -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <rend> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <rend> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <rend> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <rend> -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <rend> -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Records horizontal alignment.
      *
      * <rend> -> att.horizontalAlign -> att.horizontalAlign.attribute.halign -> @halign
      */
    `@halign`: scala.Option[DataHORIZONTALALIGNMENT] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <rend> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Used to extend the values of the rend attribute.
      *
      * <rend> -> att.textRendition -> att.textRendition.attribute.altrend -> @altrend
      */
    `@altrend`: scala.Option[java.lang.String] = scala.None,
    /** (rendition) Captures the appearance of the element’s contents using MEI-defined descriptors.
      *
      * <rend> -> att.textRendition -> att.textRendition.attribute.rend -> @rend
      */
    `@rend`: scala.Option[java.lang.String] = scala.None,
    /** Contains the name of a font-family.
      *
      * <rend> -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <rend> -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <rend> -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <rend> -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <rend> -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <rend> -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <rend> -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records vertical alignment.
      *
      * <rend> -> att.verticalAlign -> att.verticalAlign.attribute.valign -> @valign
      */
    `@valign`: scala.Option[DataVERTICALALIGNMENT] = scala.None,
    /** Allows one to signal to an application whether an element’s white space is "significant". The behavior of xml:space cascades to all descendant elements, but it can be turned off locally by setting the xml:space attribute to the value default.
      *
      * <rend> -> att.whitespace -> att.whitespace.attribute.xmlspace -> @xml:space
      */
    `@xml:space`: scala.Option[java.lang.String] = scala.None,
    /** A positive value for rotation rotates the text in a counter-clockwise fashion, while negative values produce clockwise rotation.
      *
      * <rend> -> @rotation
      */
    `@rotation`: scala.Option[DataDEGREES] = scala.None,
)

/** <respStmt>
  *
  * (responsibility statement) Transcription of text that names one or more individuals, groups, or in rare cases, mechanical processes, responsible for creation, realization, production, funding, or distribution of the intellectual or artistic content.
  */
case class RespStmt(
    /** <respStmt> -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      */
    elements: scala.List[PersName] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <respStmt> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <respStmt> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <respStmt> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <rest>
  *
  * A non-sounding event found in the source being transcribed.
  */
case class Rest(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <rest> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <rest> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <rest> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Provides a way of pointing to a MIDI instrument definition. It must contain the ID of an <instrDef> element elsewhere in the document.
      *
      * <rest> -> att.rest.ges -> att.instrumentIdent -> att.instrumentIdent.attribute.instr -> @instr
      */
    `@instr`: scala.Option[DataURI] = scala.None,
    /** Records the number of augmentation dots required by a written dotted duration.
      *
      * <rest> -> att.rest.log -> att.augmentDots -> att.augmentDots.attribute.dots -> @dots
      */
    `@dots`: scala.Option[DataAUGMENTDOT] = scala.None,
    /** <rest> -> att.rest.log -> att.cue -> att.cue.attribute.cue -> @cue
      */
    `@cue`: scala.Option[DataBOOLEAN] = scala.None,
    /** (duration) Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
      *
      * <rest> -> att.rest.log -> att.duration.log -> att.duration.log.attribute.dur -> @dur
      */
    `@dur`: scala.Option[DataDURATION] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <rest> -> att.rest.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <rest> -> att.rest.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <rest> -> att.rest.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
      *
      * <rest> -> att.rest.vis -> att.enclosingChars -> att.enclosingChars.attribute.enclose -> @enclose
      */
    `@enclose`: scala.Option[DataENCLOSURE] = scala.None,
    /** Presence of this attribute indicates that the secondary beam should be broken following this note/chord. The value of the attribute records the number of beams which should remain unbroken.
      *
      * <rest> -> att.rest.vis -> att.rest.vis.cmn -> att.beamSecondary -> att.beamSecondary.attribute.breaksec -> @breaksec
      */
    `@breaksec`: scala.Option[java.lang.String] = scala.None,
    /** Captures staff location in terms of written pitch name.
      *
      * <rest> -> att.rest.vis -> att.staffLoc.pitched -> att.staffLoc.pitched.attribute.ploc -> @ploc
      */
    `@ploc`: scala.Option[DataPITCHNAME] = scala.None,
    /** Records staff location in terms of written octave.
      *
      * <rest> -> att.rest.vis -> att.staffLoc.pitched -> att.staffLoc.pitched.attribute.oloc -> @oloc
      */
    `@oloc`: scala.Option[DataOCTAVE] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <rest> -> att.rest.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <rest> -> att.rest.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <sb>
  *
  * (system beginning) An empty formatting element that forces musical notation to begin on a new line.
  */
case class Sb(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <sb> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <sb> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <sb> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <sb> -> att.sb.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <sb> -> att.sb.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <sb> -> att.sb.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <sb> -> att.sb.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Contains the name of a font-family.
      *
      * <sb> -> att.sb.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <sb> -> att.sb.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <sb> -> att.sb.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <sb> -> att.sb.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <sb> -> att.sb.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <sb> -> att.sb.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <sb> -> att.sb.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Indicates whether hash marks should be rendered between systems. See Read, p. 436, ex. 26-3.
      *
      * <sb> -> att.sb.vis -> att.sb.vis.attribute.form -> @form
      */
    `@form`: scala.Option[java.lang.String] = scala.None,
)

/** <score>
  *
  * Full score view of the musical content.
  */
case class Score(
    /** <score> -> model.scorePart -> model.endingLike -> ending -> <ending> (-> Ending)
      * <score> -> model.milestoneLike.music -> model.pbLike -> pb -> <pb> (-> Pb)
      * <score> -> model.milestoneLike.music -> sb -> <sb> (-> Sb)
      * <score> -> model.scoreDefLike -> scoreDef -> <scoreDef> (-> ScoreDef)
      * <score> -> model.scorePart -> model.sectionLike -> section -> <section> (-> Section)
      * <score> -> model.staffDefLike -> staffDef -> <staffDef> (-> StaffDef)
      */
    elements: scala.List[Ending | Pb | Sb | ScoreDef | Section | StaffDef] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <score> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <score> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <score> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <scoreDef>
  *
  * (score definition) (score definition) – Container for score meta-information.
  */
case class ScoreDef(
    /** <scoreDef> -> pgFoot -> <pgFoot> (-> PgFoot)
      * <scoreDef> -> pgHead -> <pgHead> (-> PgHead)
      * <scoreDef> -> model.staffGrpLike -> staffGrp -> <staffGrp> (-> StaffGrp)
      */
    elements: scala.List[PgFoot | PgHead | StaffGrp] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <scoreDef> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <scoreDef> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <scoreDef> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Written key signature.
      *
      * <scoreDef> -> att.keySigDefault.log -> att.keySigDefault.log.attribute.keysig -> @keysig
      */
    `@keysig`: scala.Option[java.lang.String] = scala.None,
    /** Captures the number of beats in a measure, that is, the top number of the meter signature. It must contain a decimal number or an expression that evaluates to a decimal number, such as 2+3 or 3*2.
      *
      * <scoreDef> -> att.meterSigDefault.log -> att.meterSigDefault.log.attribute.meter.count -> @meter.count
      */
    `@meter.count`: scala.Option[java.lang.String] = scala.None,
    /** Contains the number indicating the beat unit, that is, the bottom number of the meter signature.
      *
      * <scoreDef> -> att.meterSigDefault.log -> att.meterSigDefault.log.attribute.meter.unit -> @meter.unit
      */
    `@meter.unit`: scala.Option[java.lang.String] = scala.None,
    /** Indicates the use of a meter symbol instead of a numeric meter signature, that is, 'C' for common time or 'C' with a slash for cut time.
      *
      * <scoreDef> -> att.meterSigDefault.log -> att.meterSigDefault.log.attribute.meter.sym -> @meter.sym
      */
    `@meter.sym`: scala.Option[DataMETERSIGN] = scala.None,
)

/** <section>
  *
  * Segment of music data.
  */
case class Section(
    /** <section> -> model.sectionPart -> model.endingLike -> ending -> <ending> (-> Ending)
      * <section> -> model.sectionPart -> model.sectionPart.cmn -> model.measureLike -> measure -> <measure> (-> Measure)
      * <section> -> model.milestoneLike.music -> model.pbLike -> pb -> <pb> (-> Pb)
      * <section> -> model.milestoneLike.music -> sb -> <sb> (-> Sb)
      * <section> -> model.sectionPart -> model.scoreDefLike -> scoreDef -> <scoreDef> (-> ScoreDef)
      * <section> -> model.sectionPart -> model.sectionLike -> section -> <section> (-> Section)
      * <section> -> model.sectionPart -> model.staffDefLike -> staffDef -> <staffDef> (-> StaffDef)
      */
    elements: scala.List[Ending | Measure | Pb | Sb | ScoreDef | Section | StaffDef] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <section> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <section> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <section> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Indicates that the performance of the next musical division should begin immediately following this one.
      *
      * <section> -> att.section.ges -> att.attacking -> att.attacking.attribute.attacca -> @attacca
      */
    `@attacca`: scala.Option[DataBOOLEAN] = scala.None,
    /** Indicates that staves begin again with this section.
      *
      * <section> -> att.section.vis -> att.section.vis.attribute.restart -> @restart
      */
    `@restart`: scala.Option[DataBOOLEAN] = scala.None,
)

/** <space>
  *
  * A placeholder used to fill an incomplete measure, layer, etc. most often so that the combined duration of the events equals the number of beats in the measure.
  */
case class Space(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <space> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <space> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <space> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Records the number of augmentation dots required by a written dotted duration.
      *
      * <space> -> att.space.log -> att.augmentDots -> att.augmentDots.attribute.dots -> @dots
      */
    `@dots`: scala.Option[DataAUGMENTDOT] = scala.None,
    /** (duration) Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
      *
      * <space> -> att.space.log -> att.duration.log -> att.duration.log.attribute.dur -> @dur
      */
    `@dur`: scala.Option[DataDURATION] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <space> -> att.space.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <space> -> att.space.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** "Cut-out" style.
      *
      * <space> -> att.space.vis -> att.cutout -> att.cutout.attribute.cutout -> @cutout
      */
    `@cutout`: scala.Option[java.lang.String] = scala.None,
    /** Indicates whether a space is 'compressible', i.e., if it may be removed at the discretion of processing software.
      *
      * <space> -> att.space.vis -> att.space.vis.attribute.compressable -> @compressable
      */
    `@compressable`: scala.Option[DataBOOLEAN] = scala.None,
)

/** <staff>
  *
  * A group of equidistant horizontal lines on which notes are placed in order to represent pitch or a grouping element for individual 'strands' of notes, rests, etc. that may or may not actually be rendered on staff lines; that is, both diastematic and non-diastematic signs.
  */
case class Staff(
    /** <staff> -> model.staffPart -> model.layerLike -> layer -> <layer> (-> Layer)
      * <staff> -> model.milestoneLike.music -> model.pbLike -> pb -> <pb> (-> Pb)
      * <staff> -> model.milestoneLike.music -> sb -> <sb> (-> Sb)
      * <staff> -> model.staffDefLike -> staffDef -> <staffDef> (-> StaffDef)
      */
    elements: scala.List[Layer | Pb | Sb | StaffDef] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <staff> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <staff> -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Provides a numeric designation that indicates an element’s position in a sequence of similar elements. Its value must be a non-negative integer.
      *
      * <staff> -> att.nInteger -> att.nInteger.attribute.n -> @n
      */
    `@n`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <staff> -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <staffDef>
  *
  * (staff definition) Container for staff meta-information.
  */
case class StaffDef(
    /** <staffDef> -> model.staffDefPart -> clef -> <clef> (-> Clef)
      * <staffDef> -> model.staffDefPart -> clefGrp -> <clefGrp> (-> ClefGrp)
      * <staffDef> -> model.instrDefLike -> instrDef -> <instrDef> (-> InstrDef)
      * <staffDef> -> model.labelLike -> label -> <label> (-> Label)
      * <staffDef> -> model.labelLike -> labelAbbr -> <labelAbbr> (-> LabelAbbr)
      */
    elements: scala.List[Clef | ClefGrp | InstrDef | Label | LabelAbbr] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <staffDef> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <staffDef> -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Provides a numeric designation that indicates an element’s position in a sequence of similar elements. Its value must be a non-negative integer.
      *
      * <staffDef> -> att.nInteger -> att.nInteger.attribute.n -> @n
      */
    `@n`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <staffDef> -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Provides a way of pointing to a MIDI instrument definition. It must contain the ID of an <instrDef> element elsewhere in the document.
      *
      * <staffDef> -> att.staffDef.ges -> att.instrumentIdent -> att.instrumentIdent.attribute.instr -> @instr
      */
    `@instr`: scala.Option[DataURI] = scala.None,
    /** This attribute is deprecated in favor of the new <tuning> element and will be removed in a future version. Provides a *written* pitch and octave for each open string or course of strings.
      *
      * <staffDef> -> att.staffDef.ges -> att.stringtab.tuning -> att.stringtab.tuning.attribute.tab.strings -> @tab.strings
      */
    `@tab.strings`: scala.Option[java.lang.String] = scala.None,
    /** This attribute is deprecated in favor of the new <tuning> element and will be removed in a future version. Provides a *written* pitch and octave for each open string or course of strings.
      *
      * <staffDef> -> att.staffDef.ges -> att.stringtab.tuning -> att.stringtab.tuning.attribute.tab.courses -> @tab.courses
      */
    `@tab.courses`: scala.Option[java.lang.String] = scala.None,
    /** Indicates the number of pulses (sometimes referred to as ticks or divisions) per quarter note. Unlike MIDI, MEI permits different values for a score and individual staves.
      *
      * <staffDef> -> att.staffDef.ges -> att.timeBase -> att.timeBase.attribute.ppq -> @ppq
      */
    `@ppq`: scala.Option[java.lang.String] = scala.None,
    /** Holds a value for cycles per second, i.e., Hertz, for a tuning reference pitch.
      *
      * <staffDef> -> att.staffDef.ges -> att.tuning -> att.tuning.attribute.tune.Hz -> @tune.Hz
      */
    `@tune.Hz`: scala.Option[java.lang.String] = scala.None,
    /** Holds the pitch name of a tuning reference pitch, i.e., the central tone of a tuning system.
      *
      * <staffDef> -> att.staffDef.ges -> att.tuning -> att.tuning.attribute.tune.pname -> @tune.pname
      */
    `@tune.pname`: scala.Option[DataPITCHNAME] = scala.None,
    /** Provides an indication of the tuning system, just, for example.
      *
      * <staffDef> -> att.staffDef.ges -> att.tuning -> att.tuning.attribute.tune.temper -> @tune.temper
      */
    `@tune.temper`: scala.Option[DataTEMPERAMENT] = scala.None,
    /** Encodes a value for the clef symbol.
      *
      * <staffDef> -> att.staffDef.log -> att.cleffing.log -> att.cleffing.log.attribute.clef.shape -> @clef.shape
      */
    `@clef.shape`: scala.Option[DataCLEFSHAPE] = scala.None,
    /** Contains a default value for the position of the clef. The value must be in the range between 1 and the number of lines on the staff. The numbering of lines starts with the lowest line of the staff.
      *
      * <staffDef> -> att.staffDef.log -> att.cleffing.log -> att.cleffing.log.attribute.clef.line -> @clef.line
      */
    `@clef.line`: scala.Option[DataCLEFLINE] = scala.None,
    /** Records the amount of octave displacement to be applied to the clef.
      *
      * <staffDef> -> att.staffDef.log -> att.cleffing.log -> att.cleffing.log.attribute.clef.dis -> @clef.dis
      */
    `@clef.dis`: scala.Option[DataOCTAVEDIS] = scala.None,
    /** Records the direction of octave displacement to be applied to the clef.
      *
      * <staffDef> -> att.staffDef.log -> att.cleffing.log -> att.cleffing.log.attribute.clef.dis.place -> @clef.dis.place
      */
    `@clef.dis.place`: scala.Option[DataSTAFFRELBasic] = scala.None,
    /** Written key signature.
      *
      * <staffDef> -> att.staffDef.log -> att.keySigDefault.log -> att.keySigDefault.log.attribute.keysig -> @keysig
      */
    `@keysig`: scala.Option[java.lang.String] = scala.None,
    /** Captures the number of beats in a measure, that is, the top number of the meter signature. It must contain a decimal number or an expression that evaluates to a decimal number, such as 2+3 or 3*2.
      *
      * <staffDef> -> att.staffDef.log -> att.meterSigDefault.log -> att.meterSigDefault.log.attribute.meter.count -> @meter.count
      */
    `@meter.count`: scala.Option[java.lang.String] = scala.None,
    /** Contains the number indicating the beat unit, that is, the bottom number of the meter signature.
      *
      * <staffDef> -> att.staffDef.log -> att.meterSigDefault.log -> att.meterSigDefault.log.attribute.meter.unit -> @meter.unit
      */
    `@meter.unit`: scala.Option[java.lang.String] = scala.None,
    /** Indicates the use of a meter symbol instead of a numeric meter signature, that is, 'C' for common time or 'C' with a slash for cut time.
      *
      * <staffDef> -> att.staffDef.log -> att.meterSigDefault.log -> att.meterSigDefault.log.attribute.meter.sym -> @meter.sym
      */
    `@meter.sym`: scala.Option[DataMETERSIGN] = scala.None,
    /** (transposition (diatonic)) Records the amount of diatonic pitch shift, e.g., C to C♯ = 0, C to D♭ = 1, necessary to calculate the sounded pitch from the written one.
      *
      * <staffDef> -> att.staffDef.log -> att.transposition -> att.transposition.attribute.trans.diat -> @trans.diat
      */
    `@trans.diat`: scala.Option[java.lang.String] = scala.None,
    /** (transposition (semitones)) Records the amount of pitch shift in semitones, e.g., C to C♯ = 1, C to D♭ = 1, necessary to calculate the sounded pitch from the written one.
      *
      * <staffDef> -> att.staffDef.log -> att.transposition -> att.transposition.attribute.trans.semi -> @trans.semi
      */
    `@trans.semi`: scala.Option[java.lang.String] = scala.None,
    /** Indicates the number of staff lines.
      *
      * <staffDef> -> att.staffDef.log -> att.staffDef.log.attribute.lines -> @lines
      */
    `@lines`: scala.Option[java.lang.String] = scala.None,
    /** Scale factor to be applied to the feature to make it the desired display size.
      *
      * <staffDef> -> att.staffDef.vis -> att.scalable -> att.scalable.attribute.scale -> @scale
      */
    `@scale`: scala.Option[DataPERCENT] = scala.None,
    /** Captures the colors of the staff lines.
      *
      * <staffDef> -> att.staffDef.vis -> att.staffDef.vis.attribute.lines.color -> @lines.color
      */
    `@lines.color`: scala.Option[java.lang.String] = scala.None,
    /** Records whether all staff lines are visible.
      *
      * <staffDef> -> att.staffDef.vis -> att.staffDef.vis.attribute.lines.visible -> @lines.visible
      */
    `@lines.visible`: scala.Option[DataBOOLEAN] = scala.None,
)

/** <staffGrp>
  *
  * (staff group) (staff group) – A group of bracketed or braced staves.
  */
case class StaffGrp(
    /** <staffGrp> -> model.instrDefLike -> instrDef -> <instrDef> (-> InstrDef)
      * <staffGrp> -> model.labelLike -> label -> <label> (-> Label)
      * <staffGrp> -> model.labelLike -> labelAbbr -> <labelAbbr> (-> LabelAbbr)
      * <staffGrp> -> model.staffDefLike -> staffDef -> <staffDef> (-> StaffDef)
      * <staffGrp> -> model.staffGrpLike -> staffGrp -> <staffGrp> (-> StaffGrp)
      */
    elements: scala.List[InstrDef | Label | LabelAbbr | StaffDef | StaffGrp] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <staffGrp> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <staffGrp> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <staffGrp> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Specifies the symbol used to group a set of staves.
      *
      * <staffGrp> -> att.staffGrp.vis -> att.staffGroupingSym -> att.staffGroupingSym.attribute.symbol -> @symbol
      */
    `@symbol`: scala.Option[java.lang.String] = scala.None,
    /** (bar lines through) Indicates whether bar lines go across the space between staves (true) or are only drawn across the lines of each staff (false).
      *
      * <staffGrp> -> att.staffGrp.vis -> att.staffGrp.vis.attribute.bar.thru -> @bar.thru
      */
    `@bar.thru`: scala.Option[DataBOOLEAN] = scala.None,
    /** Provides a way of pointing to a MIDI instrument definition. It must contain the ID of an <instrDef> element elsewhere in the document.
      *
      * <staffGrp> -> att.staffGrp.ges -> att.instrumentIdent -> att.instrumentIdent.attribute.instr -> @instr
      */
    `@instr`: scala.Option[DataURI] = scala.None,
)

/** <syl>
  *
  * (syllable) Individual lyric syllable.
  */
case class Syl(
    /** <syl> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <syl> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <syl> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <syl> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <syl> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <syl> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <syl> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <syl> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <syl> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <syl> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Describes the symbols typically used to indicate breaks between syllables and their functions.
      *
      * <syl> -> att.syl.log -> att.syl.log.attribute.con -> @con
      */
    `@con`: scala.Option[java.lang.String] = scala.None,
    /** Records the position of a syllable within a word.
      *
      * <syl> -> att.syl.log -> att.syl.log.attribute.wordpos -> @wordpos
      */
    `@wordpos`: scala.Option[java.lang.String] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <syl> -> att.syl.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <syl> -> att.syl.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <syl> -> att.syl.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <syl> -> att.syl.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <syl> -> att.syl.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <syl> -> att.syl.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <syl> -> att.syl.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <syl> -> att.syl.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <syl> -> att.syl.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <syl> -> att.syl.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records horizontal alignment.
      *
      * <syl> -> att.syl.vis -> att.horizontalAlign -> att.horizontalAlign.attribute.halign -> @halign
      */
    `@halign`: scala.Option[DataHORIZONTALALIGNMENT] = scala.None,
)

/** <symbol>
  *
  * A reference to a previously defined symbol.
  */
case class Symbol(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <symbol> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <symbol> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <symbol> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <symbol> -> att.symbol.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <symbol> -> att.symbol.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <symbol> -> att.symbol.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <symbol> -> att.symbol.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <symbol> -> att.symbol.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Scale factor to be applied to the feature to make it the desired display size.
      *
      * <symbol> -> att.symbol.vis -> att.scalable -> att.scalable.attribute.scale -> @scale
      */
    `@scale`: scala.Option[DataPERCENT] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <symbol> -> att.symbol.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <symbol> -> att.symbol.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <tempo>
  *
  * Text and symbols descriptive of tempo, mood, or style, e.g., "allarg.", "a tempo", "cantabile", "Moderato", "♩=60", "Moderato ♩ =60").
  */
case class Tempo(
    /** <tempo> -> model.textPhraseLike.limited -> model.lbLike -> lb -> <lb> (-> Lb)
      * <tempo> -> model.textPhraseLike.limited -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <tempo> -> model.textPhraseLike.limited -> model.rendLike -> rend -> <rend> (-> Rend)
      * <tempo> -> model.textPhraseLike.limited -> symbol -> <symbol> (-> Symbol)
      * <tempo> -> model.textPhraseLike.limited -> model.titleLike -> title -> <title> (-> Title)
      * <tempo> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | PersName | Rend | Symbol | Title | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <tempo> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <tempo> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <tempo> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <tempo> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Captures the number of *quarter notes* per minute. In MIDI, a beat is always defined as a quarter note, *not the numerator of the time signature or the metronomic indication*.
      *
      * <tempo> -> att.tempo.ges -> att.midiTempo -> att.midiTempo.attribute.midi.bpm -> @midi.bpm
      */
    `@midi.bpm`: scala.Option[DataMIDIBPM] = scala.None,
    /** Records the number of microseconds per *quarter note*. In MIDI, a beat is always defined as a quarter note, *not the numerator of the time signature or the metronomic indication*. At 120 quarter notes per minute, each quarter note will last 500,000 microseconds.
      *
      * <tempo> -> att.tempo.ges -> att.midiTempo -> att.midiTempo.attribute.midi.mspb -> @midi.mspb
      */
    `@midi.mspb`: scala.Option[DataMIDIMSPB] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <tempo> -> att.tempo.log -> att.controlEvent -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
      *
      * <tempo> -> att.tempo.log -> att.controlEvent -> att.plist -> att.plist.attribute.plist -> @plist
      */
    `@plist`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <tempo> -> att.tempo.log -> att.controlEvent -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      *
      * <tempo> -> att.tempo.log -> att.controlEvent -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** Used to describe tempo in terms of beats (often the meter signature denominator) per minute, ala M.M. (Maelzel’s Metronome). Do not confuse this attribute with midi.bpm or midi.mspb. In MIDI, a beat is always defined as a quarter note, *not the numerator of the time signature or the metronomic indication*.
      *
      * <tempo> -> att.tempo.log -> att.mmTempo -> att.mmTempo.attribute.mm -> @mm
      */
    `@mm`: scala.Option[DataTEMPOVALUE] = scala.None,
    /** Captures the metronomic unit.
      *
      * <tempo> -> att.tempo.log -> att.mmTempo -> att.mmTempo.attribute.mm.unit -> @mm.unit
      */
    `@mm.unit`: scala.Option[DataDURATION] = scala.None,
    /** Records the number of augmentation dots required by a dotted metronome unit.
      *
      * <tempo> -> att.tempo.log -> att.mmTempo -> att.mmTempo.attribute.mm.dots -> @mm.dots
      */
    `@mm.dots`: scala.Option[DataAUGMENTDOT] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <tempo> -> att.tempo.log -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <tempo> -> att.tempo.log -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
      *
      * <tempo> -> att.tempo.log -> att.timestamp2.log -> att.timestamp2.log.attribute.tstamp2 -> @tstamp2
      */
    `@tstamp2`: scala.Option[DataMEASUREBEAT] = scala.None,
    /** Records the function of a tempo indication.
      *
      * <tempo> -> att.tempo.log -> att.tempo.log.attribute.func -> @func
      */
    `@func`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <tempo> -> att.tempo.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** Describes the style of a line.
      *
      * <tempo> -> att.tempo.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lform -> @lform
      */
    `@lform`: scala.Option[DataLINEFORM] = scala.None,
    /** Width of a line.
      *
      * <tempo> -> att.tempo.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lwidth -> @lwidth
      */
    `@lwidth`: scala.Option[DataLINEWIDTH] = scala.None,
    /** Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
      *
      * <tempo> -> att.tempo.vis -> att.extender -> att.lineRend -> att.lineRend.base -> att.lineRend.base.attribute.lsegs -> @lsegs
      */
    `@lsegs`: scala.Option[java.lang.String] = scala.None,
    /** (line end symbol) Symbol rendered at end of line.
      *
      * <tempo> -> att.tempo.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym -> @lendsym
      */
    `@lendsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-end symbol.
      *
      * <tempo> -> att.tempo.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lendsym.size -> @lendsym.size
      */
    `@lendsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** (line start symbol) Symbol rendered at start of line.
      *
      * <tempo> -> att.tempo.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym -> @lstartsym
      */
    `@lstartsym`: scala.Option[DataLINESTARTENDSYMBOL] = scala.None,
    /** Holds the relative size of the line-start symbol.
      *
      * <tempo> -> att.tempo.vis -> att.extender -> att.lineRend -> att.lineRend.attribute.lstartsym.size -> @lstartsym.size
      */
    `@lstartsym.size`: scala.Option[DataFONTSIZESCALE] = scala.None,
    /** Indicates the presence of an extension symbol, typically a line.
      *
      * <tempo> -> att.tempo.vis -> att.extender -> att.extender.attribute.extender -> @extender
      */
    `@extender`: scala.Option[DataBOOLEAN] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <tempo> -> att.tempo.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <tempo> -> att.tempo.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <tempo> -> att.tempo.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined start point.
      *
      * <tempo> -> att.tempo.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.startho -> @startho
      */
    `@startho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the horizontal adjustment of a feature’s programmatically-determined end point.
      *
      * <tempo> -> att.tempo.vis -> att.visualOffset2.ho -> att.visualOffset2.ho.attribute.endho -> @endho
      */
    `@endho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <title>
  *
  * Title of a bibliographic entity.
  */
case class Title(
    /** <title> -> macro.titlePart -> model.lbLike -> lb -> <lb> (-> Lb)
      * <title> -> macro.titlePart -> model.pbLike -> pb -> <pb> (-> Pb)
      * <title> -> macro.titlePart -> model.nameLike -> model.nameLike.agent -> persName -> <persName> (-> PersName)
      * <title> -> macro.titlePart -> model.rendLike -> rend -> <rend> (-> Rend)
      * <title> -> macro.titlePart -> symbol -> <symbol> (-> Symbol)
      * <title> -> text (-> java.lang.String)
      */
    elements: scala.List[Lb | Pb | PersName | Rend | Symbol | java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <title> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <title> -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
      *
      * <title> -> att.lang -> att.lang.attribute.xmllang -> @xml:lang
      */
    `@xml:lang`: scala.Option[java.lang.String] = scala.None,
    /** Provides a number-like designation that indicates an element’s position in a sequence of similar elements. May not contain space characters.
      *
      * <title> -> att.nNumberLike -> att.nNumberLike.attribute.n -> @n
      */
    `@n`: scala.Option[DataWORD] = scala.None,
    /** Indicates the bibliographic level of the title.
      *
      * <title> -> @level
      */
    `@level`: scala.Option[java.lang.String] = scala.None,
    /** Characterizes the title in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * Suggested values include: 1] main; 2] subordinate; 3] abbreviated; 4] alternative; 5] translated; 6] uniform; 7] desc
      *
      * <title> -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
)

/** <barre>
  *
  * A barre in a chord tablature grid.
  */
case class Barre(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <barre> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <barre> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <barre> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Holds a reference to the first element in a sequence of events to which the feature applies.
      *
      * <barre> -> att.startEndId -> att.startId -> att.startId.attribute.startid -> @startid
      */
    `@startid`: scala.Option[DataURI] = scala.None,
    /** Indicates the final element in a sequence of events to which the feature applies.
      *
      * <barre> -> att.startEndId -> att.startEndId.attribute.endid -> @endid
      */
    `@endid`: scala.Option[DataURI] = scala.None,
    /** This attribute is deprecated in favor of @tab.fret, and will be removed in a future version. Records the location at which the strings should be stopped against a fret in a fretboard diagram. This may or may not be the same as the actual location on the fretboard of the instrument in performance.
      *
      * <barre> -> @fret
      */
    `@fret`: scala.Option[java.lang.String] = scala.None,
)

/** <string>
  *
  * (individual string tuning information) Used to modify tuning information given by the course element. Describes the tuning of an individual string within a course on a stringed instrument (e.g., guitar, lute).
  */
case class String(
    /** <string> -> string -> <string> (-> String)
      */
    elements: scala.List[String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <string> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <string> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <string> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Captures a written accidental.
      *
      * <string> -> att.course.log -> att.accidental -> att.accidental.attribute.accid -> @accid
      */
    `@accid`: scala.Option[DataACCIDENTALWRITTEN] = scala.None,
    /** (pitch name) Contains a written pitch name.
      *
      * <string> -> att.course.log -> att.pitched -> att.pitch -> att.pitch.attribute.pname -> @pname
      */
    `@pname`: scala.Option[DataPITCHNAME] = scala.None,
    /** (octave) Captures written octave information.
      *
      * <string> -> att.course.log -> att.pitched -> att.octave -> att.octave.attribute.oct -> @oct
      */
    `@oct`: scala.Option[DataOCTAVE] = scala.None,
)

/** <tabDurSym>
  *
  * A visual indication of the duration of a <tabGrp>.
  */
case class TabDurSym(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <tabDurSym> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <tabDurSym> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <tabDurSym> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** This attribute is deprecated and will be removed in a future version. Indicates which finger, if any, should be used to play an individual string. The index, middle, ring, and little fingers are represented by the values 1-4, while t is for the thumb. The values x and o indicate muffled and open strings, respectively.
      *
      * <tabDurSym> -> att.stringtab -> att.stringtab.attribute.tab.fing -> @tab.fing
      */
    `@tab.fing`: scala.Option[DataFINGERFRET] = scala.None,
    /** Records the location at which a string should be stopped against a fret.
      *
      * <tabDurSym> -> att.stringtab -> att.stringtab.attribute.tab.fret -> @tab.fret
      */
    `@tab.fret`: scala.Option[DataFRETNUMBER] = scala.None,
    /** Used in German lute tablature in cases where vertical positioning deviates from the norm which can be specified by @tab.align. Indicates the position of the tab note on one of the horizontal strands corresponding to the @lines attribute on <staffDef>. (Note that in this case, the lines are conceptual rather than visible).
      *
      * <tabDurSym> -> att.stringtab -> att.stringtab.attribute.tab.line -> @tab.line
      */
    `@tab.line`: scala.Option[DataCLEFLINE] = scala.None,
    /** This attribute is deprecated in favor of @tab.course and will be removed in a future version. Records which string is to be played.
      *
      * <tabDurSym> -> att.stringtab -> att.stringtab.attribute.tab.string -> @tab.string
      */
    `@tab.string`: scala.Option[DataSTRINGNUMBER] = scala.None,
    /** Records which course is to be played.
      *
      * <tabDurSym> -> att.stringtab -> att.stringtab.attribute.tab.course -> @tab.course
      */
    `@tab.course`: scala.Option[DataCOURSENUMBER] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <tabDurSym> -> att.tabDurSym.log -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.color -> att.color.attribute.color -> @color
      */
    `@color`: scala.Option[DataCOLOR] = scala.None,
    /** A name or label associated with the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      * Suggested values include: 1] smufl
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.auth -> @glyph.auth
      */
    `@glyph.auth`: scala.Option[java.lang.String] = scala.None,
    /** The web-accessible location of the controlled vocabulary from which the value of @glyph.name or @glyph.num is taken, or the textual content of the element.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.extSym -> att.extSym.auth -> att.extSym.auth.attribute.glyph.uri -> @glyph.uri
      */
    `@glyph.uri`: scala.Option[DataURI] = scala.None,
    /** Glyph name.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.name -> @glyph.name
      */
    `@glyph.name`: scala.Option[java.lang.String] = scala.None,
    /** Numeric glyph reference in hexadecimal notation, e.g., "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.extSym -> att.extSym.names -> att.extSym.names.attribute.glyph.num -> @glyph.num
      */
    `@glyph.num`: scala.Option[DataHEXNUM] = scala.None,
    /** Captures the placement of the item with respect to the staff with which it is associated.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.placementRelStaff -> att.placementRelStaff.attribute.place -> @place
      */
    `@place`: scala.Option[DataSTAFFREL] = scala.None,
    /** Contains the name of a font-family.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.typography -> att.typography.attribute.fontfam -> @fontfam
      */
    `@fontfam`: scala.Option[DataFONTFAMILY] = scala.None,
    /** Holds the name of a font.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.typography -> att.typography.attribute.fontname -> @fontname
      */
    `@fontname`: scala.Option[DataFONTNAME] = scala.None,
    /** Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., small, larger, etc., or percentage values relative to normal size, e.g., 125%.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.typography -> att.typography.attribute.fontsize -> @fontsize
      */
    `@fontsize`: scala.Option[DataFONTSIZE] = scala.None,
    /** Records the style of a font, i.e., italic, oblique, or normal.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.typography -> att.typography.attribute.fontstyle -> @fontstyle
      */
    `@fontstyle`: scala.Option[DataFONTSTYLE] = scala.None,
    /** Used to indicate bold type.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.typography -> att.typography.attribute.fontweight -> @fontweight
      */
    `@fontweight`: scala.Option[DataFONTWEIGHT] = scala.None,
    /** Indicates letter spacing (aka tracking) in analogy to the CSS letter-spacing property.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.typography -> att.typography.attribute.letterspacing -> @letterspacing
      */
    `@letterspacing`: scala.Option[DataMEASUREMENTTYPOGRAPHYSIGNED] = scala.None,
    /** Indicates line height in analogy to the CSS line-height property.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.typography -> att.typography.attribute.lineheight -> @lineheight
      */
    `@lineheight`: scala.Option[DataMEASUREMENTTYPOGRAPHYUNSIGNED] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.visualOffset -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
    /** Records the vertical adjustment of a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <tabDurSym> -> att.tabDurSym.vis -> att.visualOffset -> att.visualOffset.vo -> att.visualOffset.vo.attribute.vo -> @vo
      */
    `@vo`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)

/** <tabGrp>
  *
  * A group of simultaneous tab notes, comparable to a <chord> in CMN. Rarely, may also contain rests, as in some "German" lute tablatures.
  */
case class TabGrp(
    /** <tabGrp> -> note -> <note> (-> Note)
      * <tabGrp> -> rest -> <rest> (-> Rest)
      * <tabGrp> -> tabDurSym -> <tabDurSym> (-> TabDurSym)
      */
    elements: scala.List[Note | Rest | TabDurSym] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      *
      * <tabGrp> -> att.common -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Captures text to be used to generate a label for the element to which it’s attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
      *
      * <tabGrp> -> att.common -> att.labelled -> att.labelled.attribute.label -> @label
      */
    `@label`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      *
      * <tabGrp> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Records the number of augmentation dots required by a written dotted duration.
      *
      * <tabGrp> -> att.tabGrp.log -> att.augmentDots -> att.augmentDots.attribute.dots -> @dots
      */
    `@dots`: scala.Option[DataAUGMENTDOT] = scala.None,
    /** (duration) Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
      *
      * <tabGrp> -> att.tabGrp.log -> att.duration.log -> att.duration.log.attribute.dur -> @dur
      */
    `@dur`: scala.Option[DataDURATION] = scala.None,
    /** Identifies the layer to which a feature applies.
      *
      * <tabGrp> -> att.tabGrp.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      *
      * <tabGrp> -> att.tabGrp.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** Records a horizontal adjustment to a feature’s programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
      *
      * <tabGrp> -> att.tabGrp.vis -> att.visualOffset.ho -> att.visualOffset.ho.attribute.ho -> @ho
      */
    `@ho`: scala.Option[DataMEASUREMENTSIGNED] = scala.None,
)
