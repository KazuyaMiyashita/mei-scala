package generator

import MeiModel.*

object MeiModelWriter {

  /** Takes a list of definitions and generates the content of a single Scala file as a string.
    *
    * @param definitions List of semantic models
    * @param packageName Package name for output
    * @return Scala source code
    */
  def generate(definitions: List[MeiModel], packageName: String): String = {
    val sb = new StringBuilder

    // Generate header
    sb.append(s"package $packageName\n\n")
    sb.append("// This file is auto-generated from MEI RelaxNG schema.\n")
    sb.append("// Do not edit this file manually.\n\n")

    // Write out each definition
    definitions.foreach {
      case defn: MeiTrait if defn.name.startsWith("Att")            => ()
      case defn: MeiTypeAlias if defn.targetType == "scala.Nothing" => ()
      case defn                                                     =>
        sb.append(writeDefinition(defn))
        sb.append("\n\n")
    }

    sb.toString()
  }

  private def writeDefinition(defn: MeiModel): String = defn match {
    case cls: MeiElement     => writeClass(cls)
    case alias: MeiTypeAlias => writeTypeAlias(alias)
    case trt: MeiTrait       => writeTrait(trt) // Should not reach here if filtered in generate
  }

  /** Helper for Scaladoc generation
    * @param doc Document body
    * @param indent Indentation
    * @param header Header string to display on the first line of the document (e.g., "<elementName>", "model.groupName")
    */
  private def writeDoc(doc: Option[String], indent: String = "", header: Option[String] = None): String = {
    (doc, header) match {
      case (None, None) => ""
      case _            =>
        val sb = new StringBuilder
        sb.append(s"$indent/**")

        header match {
          case Some(h) =>
            sb.append(s" $h")
            doc match {
              case Some(text) =>
                // Header + Doc
                sb.append(s"\n$indent  *") // Newline after header
                text.linesIterator.foreach { line =>
                  sb.append(s"\n$indent  * $line")
                }
              case None =>
              // Header only, do nothing more
            }
          case None =>
            // Doc only
            doc match {
              case Some(text) =>
                val lines = text.linesIterator.toList
                if (lines.nonEmpty) {
                  sb.append(s" ${lines.head}")
                  lines.tail.foreach { line =>
                    sb.append(s"\n$indent  * $line")
                  }
                }
              case None => // unreachable
            }
        }

        sb.append(s"\n$indent  */\n")
        sb.toString()
    }
  }

  /** Generate type alias */
  private def writeTypeAlias(alias: MeiTypeAlias): String = {
    val docName = formatTraitDocName(alias.originalName)
    val docStr  = writeDoc(alias.doc, header = Some(docName))
    val name    = sanitizeName(alias.name)
    s"${docStr}type $name = ${alias.targetType}"
  }

  /** Generate case class */
  private def writeClass(cls: MeiElement): String = {
    // For Class(Element), use the <OriginalName> format
    val docStr    = writeDoc(cls.doc, header = Some(s"<${cls.originalName}>"))
    val className = sanitizeName(cls.name)

    // Only structural traits are inherited.
    // Since attributes are held directly as fields, extendsClause does not include attribute traits.
    val structuralParents = cls.parents.filterNot(p => p.startsWith("Att")).map(sanitizeName)
    val extendsClause     = if (structuralParents.isEmpty) "" else s" extends ${structuralParents.mkString(" with ")}"

    val fieldsStr = cls.fields
      .map { case f =>
        val fDoc    = writeDoc(f.doc, indent = "    ")
        val typeStr = mapType(f.types, f.cardinality)

        val defaultValue = f.cardinality match {
          case Cardinality.Optional => " = scala.None"
          case Cardinality.Multiple => " = scala.Nil"
          case _                    => ""
        }

        s"${fDoc}    ${f.name}: $typeStr$defaultValue,"
      }
      .mkString("\n")

    s"""${docStr}case class ${className}(
${fieldsStr.stripSuffix(",")}
)${extendsClause}"""
  }

  /** Generate trait */
  private def writeTrait(trt: MeiTrait): String = {
    // For Trait(Define), use the OriginalName format (without angle brackets)
    val docName   = formatTraitDocName(trt.originalName)
    val docStr    = writeDoc(trt.doc, header = Some(docName))
    val traitName = sanitizeName(trt.name)

    val extendsClause = if (trt.parents.isEmpty) "" else s" extends ${trt.parents.map(sanitizeName).mkString(" with ")}"

    // Since fields have been removed from MeiTrait, always generate a trait with an empty body
    s"""${docStr}trait ${traitName}${extendsClause} {}"""
  }

  /** Returns the Scala type representation corresponding to the cardinality */

  private def mapType(types: List[String], cardinality: Cardinality): String = {

    // Exclude Nothing

    val effectiveTypes = types.filterNot(_ == "scala.Nothing")

    val base = if (effectiveTypes.isEmpty) {

      "scala.Nothing" // If all are Nothing, then Nothing

    } else {

      // Type mapping (e.g., String -> java.lang.String)

      val mapped = effectiveTypes.map {

        case "token" | "NMTOKEN" => "java.lang.String"

        case "integer" | "positiveInteger" => "Int" // For future expansion

        case other => other

      }

      mapped.mkString(" | ")

    }

    cardinality match {

      case Cardinality.Required => base

      case Cardinality.Optional => s"scala.Option[$base]"

      case Cardinality.Multiple => s"scala.List[$base]"

    }

  }

  /** Converts MEI names (e.g., att.common) to Scala class names (AttCommon) */
  private def sanitizeName(name: String): String = {
    // "att.common" -> ["att", "common"] -> "AttCommon"
    // "mei_application" -> "MeiApplication"
    name
      .split("[._]")
      .map { case part =>
        if (part.nonEmpty) s"${part.head.toUpper}${part.tail}" else ""
      }
      .mkString
  }

  // Helper to format trait names for documentation
  // mei_model.pubStmtPart -> model.pubStmtPart
  // mei_macro.availabilityPart -> macro.availabilityPart
  private def formatTraitDocName(originalName: String): String = {
    if (originalName.startsWith("mei_")) {
      originalName.replaceFirst("mei_", "")
    } else {
      originalName
    }
  }

}
