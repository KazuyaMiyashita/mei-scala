package generator

import MeiModel.*

object MeiModelWriterWriter {

  def generate(definitions: List[MeiModel], basePackageName: String): String = {
    val classes           = definitions.collect { case c: MeiElement => c }
    val writerPackageName = basePackageName + ".writer"

    val sb = new StringBuilder
    sb.append(s"package $writerPackageName\n\n")
    sb.append("// This file is auto-generated from MEI RelaxNG schema.\n")
    sb.append("// Do not edit this file manually.\n\n")
    sb.append("import scala.xml.{Node, Elem, Null, TopScope, UnprefixedAttribute, MetaData}\n")
    sb.append(s"import $basePackageName.*\n\n")

    sb.append(
      "/** Although this abstraction is not strictly necessary, it is provided to prevent the linter from warning about an unused variable in def toXml for a class that has no fields. */\n",
    )
    sb.append("trait MeiModelDummyWriter[T] {\n")
    sb.append("  def toXml(obj: T): scala.xml.Node\n")
    sb.append("}\n\n")

    // ---------------------------------------------------------
    // Entry Point
    // ---------------------------------------------------------
    sb.append("object MeiXmlWriter {\n")
    sb.append("  def toXml(obj: Any): Node = obj match {\n")
    classes.sortBy(_.name).foreach { c =>
      sb.append(s"    case x: ${c.name} => ${c.name}Writer.toXml(x)\n")
    }
    sb.append("    case x: java.lang.String => scala.xml.Text(x)\n")
    sb.append("    case x: scala.xml.Node => x\n") // NodeSeq / Node support
    sb.append(
      "    case x: Seq[_] => throw new IllegalArgumentException(s\"Seq passed to toXml (should be handled by caller or flattened): $x\")\n",
    )
    sb.append("    case _ => scala.xml.Text(obj.toString)\n")
    sb.append("  }\n")
    sb.append("}\n\n")

    // ---------------------------------------------------------
    // Class Writers
    // ---------------------------------------------------------
    classes.sortBy(_.name).foreach { c =>
      sb.append(genClassWriter(c))
      sb.append("\n")
    }

    sb.toString()
  }

  private def genClassWriter(c: MeiElement): String = {
    val className = c.name
    val tagName   = c.originalName

    val sb = new StringBuilder
    sb.append(s"object ${className}Writer extends MeiModelDummyWriter[$className] {\n")
    sb.append(s"  def toXml(obj: $className): Elem = {\n")

    val attrFields = c.fields.filter(_.name.startsWith("`@"))

    if (attrFields.nonEmpty) {
      sb.append("    var attributes: MetaData = Null\n")
      // 1. Attributes
      attrFields.foreach { case f =>
        val cleanName = f.name.replaceAll("`", "").stripPrefix("@")
        // Scala field access
        val fieldAccess = s"obj.${f.name}"

        f.cardinality match {
          case Cardinality.Optional =>
            sb.append(
              s"    $fieldAccess.foreach { v => attributes = new UnprefixedAttribute(\"$cleanName\", v, attributes) }\n",
            )
          case Cardinality.Required =>
            sb.append(s"    attributes = new UnprefixedAttribute(\"$cleanName\", $fieldAccess, attributes)\n")
          case Cardinality.Multiple =>
            sb.append(
              s"    $fieldAccess.foreach { v => attributes = new UnprefixedAttribute(\"$cleanName\", v, attributes) }\n",
            )
        }
      }
    }

    // 2. Children (elements, value, mixed)
    // We collect all children nodes into a list
    sb.append("\n    val children: scala.collection.immutable.List[Node] = ")

    val elementsField = c.fields.find(_.name == "elements")
    val valueField    = c.fields.find(f => f.name == "value" || f.name == "content") // Adjust if needed

    if (elementsField.isDefined) {
      sb.append(s"obj.elements.flatMap {\n")
      sb.append("      case x => Some(MeiXmlWriter.toXml(x))\n")
      sb.append("    }")
    } else if (valueField.isDefined) {
      val f = valueField.get
      f.cardinality match {
        case Cardinality.Multiple =>
          sb.append(s"obj.${f.name}.map(scala.xml.Text(_))")
        case Cardinality.Optional =>
          sb.append(s"obj.${f.name}.map(scala.xml.Text(_)).toList")
        case Cardinality.Required =>
          sb.append(s"scala.collection.immutable.List(scala.xml.Text(obj.${f.name}.toString))")
      }
    } else {
      val anyXmlField = c.fields.find(f => f.types.contains("scala.xml.NodeSeq") || f.types.contains("NodeSeq"))

      if (anyXmlField.isDefined) {
        val f = anyXmlField.get
        f.cardinality match {
          case Cardinality.Multiple =>
            sb.append(s"obj.${f.name}.toList")
          case Cardinality.Optional =>
            sb.append(s"obj.${f.name}.map(_.toList).getOrElse(scala.collection.immutable.Nil)")
          case Cardinality.Required =>
            sb.append(s"obj.${f.name}.toList")
        }
      } else {
        sb.append("scala.collection.immutable.Nil")
      }
    }

    sb.append("\n\n")

    val attrVar = if (attrFields.nonEmpty) "attributes" else "Null"
    sb.append(s"    Elem(null, \"$tagName\", $attrVar, TopScope, true, children*)\n")
    sb.append("  }\n")
    sb.append("}\n")

    sb.toString()
  }
}
