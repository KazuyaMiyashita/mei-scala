package generator

import MeiModel.*

object MeiModelParserWriter {

  def generate(definitions: List[MeiModel], basePackageName: String): String = {
    // 1. Build Metadata Maps
    val classes = definitions.collect { case c: MeiElement => c }
    val aliases = definitions.collect { case a: MeiTypeAlias => a }

    val classMap = classes.map(c => c.name -> c).toMap
    val aliasMap = aliases.map(a => a.name -> a.targetType).toMap

    // Map: TraitName -> List[SClass]
    val traitImplementers = scala.collection.mutable.Map[String, List[MeiElement]]().withDefaultValue(Nil)
    classes.foreach { case c =>
      c.parents.foreach { case p =>
        traitImplementers(p) = traitImplementers(p) :+ c
      }
    }

    val parserPackageName = basePackageName + ".parser"

    val sb = new StringBuilder
    sb.append(s"package $parserPackageName\n\n")
    sb.append("// This file is auto-generated from MEI RelaxNG schema.\n")
    sb.append("// Do not edit this file manually.\n\n")
    sb.append("import scala.xml.{Node, NodeSeq, Elem}\n")
    sb.append(s"import $basePackageName.*\n\n")

    sb.append(
      "/** Although this abstraction is not strictly necessary, it is provided to prevent the linter from warning about an unused variable in def parse for a class that has no fields. */\ntrait MeiModelDummyParser {\n  def parse(node: Node): Any\n}\n\n",
    )

    // 3. Generate Class Parsers
    classes.foreach { case c =>
      sb.append(genClassParser(c, classMap, aliasMap, parserPackageName))
      sb.append("\n")
    }

    // 4. Generate Trait Parsers
    // Structural traits have been deprecated, so trait parsers other than attribute traits might be unnecessary,
    // but generate them if they remain. However, structural traits should no longer be generated with this change.
    val structuralTraitImplementers = traitImplementers.filterNot { case (traitName, _) =>
      traitName.startsWith("Att")
    }

    structuralTraitImplementers.foreach { case (traitName, impls) =>
      if (impls.nonEmpty) {
        sb.append(genTraitParser(traitName, impls, parserPackageName))
        sb.append("\n")
      }
    }

    sb.toString()
  }

  private def genClassParser(
      c: MeiElement,
      classMap: Map[String, MeiElement],
      aliasMap: Map[String, String],
      packageName: String,
  ): String = {
    val className = c.name
    val params    = c.fields
      .map { case f =>
        genField(f, classMap, aliasMap, packageName)
      }
      .mkString(",\n      ")

    s"""object ${className}Parser extends MeiModelDummyParser {
       |  def parse(node: Node): $className = {
       |    $className(
       |      $params
       |    )
       |  }
       |}""".stripMargin
  }

  private def genField(
      f: MeiField,
      classMap: Map[String, MeiElement],
      aliasMap: Map[String, String],
      packageName: String,
  ): String = {

    val cleanName = f.name.replaceAll("`", "")
    // Treat the first element of the types list as the primary type (for compatibility with previous logic)
    // Should typically be only one for fields other than 'elements'
    val primaryType = f.types.headOption.getOrElse("String")

    // 1. Attribute
    if (cleanName.startsWith("@")) {
      val attrName = cleanName.stripPrefix("@")
      f.cardinality match {
        case Cardinality.Optional => s"node.attribute(\"$attrName\").map(_.text)"
        case Cardinality.Required => s"node.attribute(\"$attrName\").map(_.text).get"
        case Cardinality.Multiple => s"node.attribute(\"$attrName\").map(_.text).toList"
      }
    }
    // 2. Text Content (value)
    else if (
      f.name == "value" && (primaryType == "java.lang.String" || aliasMap.get(primaryType).contains("java.lang.String"))
    ) {
      if (f.cardinality == Cardinality.Multiple) "scala.List(node.text)" else "node.text"
    }
    // 3. Any (XML)
    else if (primaryType == "scala.xml.NodeSeq" || primaryType == "NodeSeq") {
      f.cardinality match {
        case Cardinality.Multiple => "node.child.map(scala.xml.NodeSeq.fromSeq).toList"
        case Cardinality.Optional => "node.child.headOption.map(scala.xml.NodeSeq.fromSeq)"
        case Cardinality.Required => "scala.xml.NodeSeq.fromSeq(node.child)"
      }
    }
    // 4. Elements (New logic for mixed children)
    else if (f.name == "elements") {
      val elementCases = f.types.flatMap { typeName =>
        classMap.get(typeName).map { case cls =>
          s"        case n: Elem if n.label == \"${cls.originalName}\" => ${packageName}.${typeName}Parser.parse(n)"
        }
      }

      // If String type is included (Text node)
      val textCase = if (f.types.contains("java.lang.String")) {
        // Only non-empty text after trimming, or all text?
        // In mixed content, text is usually treated as an element.
        Some(s"        case n if n.text.trim.nonEmpty => n.text")
      } else None

      val allCases = elementCases ++ textCase

      if (allCases.nonEmpty) {
        s"""node.child.collect {
${allCases.mkString("\n")}        }.toList"""
      } else {
        "Nil"
      }
    }
    // 5. Child Elements (Old logic, fallback)
    else {
      // This path should ideally not be taken as fields are integrated into 'elements', but kept as a fallback.
      val isList   = f.cardinality == Cardinality.Multiple
      val isOption = f.cardinality == Cardinality.Optional

      val findLogic = if (classMap.contains(primaryType)) {
        val childTag   = classMap(primaryType).originalName
        val parserCall = s"$packageName.${primaryType}Parser.parse(n)"
        s"node.child.collect { case n: Elem if n.label == \"$childTag\" => $parserCall }"
      } else {
        s"Nil /* parsing $primaryType not implemented */"
      }

      if (isList) {
        if (findLogic.startsWith("Nil")) "Nil" else s"$findLogic.toList"
      } else if (isOption) {
        if (findLogic.startsWith("Nil")) "scala.None" else s"$findLogic.headOption"
      } else {
        if (findLogic.startsWith("Nil")) "throw new RuntimeException(\"Not implemented\")" else s"$findLogic.head"
      }
    }
  }

  private def genTraitParser(traitName: String, impls: List[MeiElement], packageName: String): String = {
    val cases = impls
      .map { case c =>
        s"    case \"${c.originalName}\" => ${packageName}.${c.name}Parser.parse(node)"
      }
      .mkString("\n")

    s"""object ${traitName}Parser extends MeiModelDummyParser {
       |  def parse(node: Node): $traitName = {
       |    node.label match {
       |$cases
       |      case _ => throw new RuntimeException(s"Unknown tag $${node.label} for trait $traitName")
       |    }
       |  }
       |}""".stripMargin
  }
}
