package mei.minimum

// This file is auto-generated from MEI RelaxNG schema.
// Do not edit this file manually.

/** data.AUGMENTDOT
  */
type DataAUGMENTDOT = java.lang.String

/** data.BEAT
  */
type DataBEAT = java.lang.String

/** data.BOOLEAN
  */
type DataBOOLEAN = java.lang.String

/** data.DURATION
  */
type DataDURATION = java.lang.String

/** data.OCTAVE
  */
type DataOCTAVE = java.lang.String

/** data.PITCHNAME
  */
type DataPITCHNAME = java.lang.String

/** data.URI
  */
type DataURI = java.lang.String

/** <fileDesc>
  *
  * (file description) Contains a full bibliographic description of the MEI file.
  */
case class FileDesc(
    /** <fileDesc> -> titleStmt -> <titleStmt> (-> TitleStmt)
      */
    elements: scala.List[TitleStmt] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <fileDesc> -> att.common -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <fileDesc> -> att.common -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <fileDesc> -> att.common -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <fileDesc> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None
)

/** <meiHead>
  *
  * (MEI header) Supplies the descriptive and declarative metadata prefixed to every MEI-conformant text.
  */
case class MeiHead(
    /** <meiHead> -> fileDesc -> <fileDesc> (-> FileDesc)
      */
    elements: scala.List[FileDesc] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <meiHead> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <meiHead> -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Specifies a generic MEI version label.
      * 
      * <meiHead> -> att.meiVersion -> att.meiVersion.attribute.meiversion -> @meiversion
      */
    `@meiversion`: scala.Option[java.lang.String] = scala.None,
    /** Specifies the kind of document to which the header is attached, for example whether it is a corpus or individual text.
      * 
      * <meiHead> -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None
)

/** <titleStmt>
  *
  * (title statement) Container for title and responsibility meta-data.
  */
case class TitleStmt(
    /** <titleStmt> -> model.titleLike -> title -> <title> (-> Title)
      */
    elements: scala.List[Title] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <titleStmt> -> att.common -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <titleStmt> -> att.common -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <titleStmt> -> att.common -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <titleStmt> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None
)

/** model.keySigLike_sequence
  */
type ModelKeySigLikeSequence = java.lang.String

/** model.keySigLike_sequenceOptional
  */
type ModelKeySigLikeSequenceOptional = java.lang.String

/** model.keySigLike_sequenceOptionalRepeatable
  */
type ModelKeySigLikeSequenceOptionalRepeatable = java.lang.String

/** model.layerPart.mensuralAndNeumes
  */
type ModelLayerPartMensuralAndNeumes = java.lang.String

/** model.meterSigLike_sequence
  */
type ModelMeterSigLikeSequence = java.lang.String

/** model.meterSigLike_sequenceOptional
  */
type ModelMeterSigLikeSequenceOptional = java.lang.String

/** model.meterSigLike_sequenceOptionalRepeatable
  */
type ModelMeterSigLikeSequenceOptionalRepeatable = java.lang.String

/** model.milestoneLike.music
  */
type ModelMilestoneLikeMusic = java.lang.String

/** model.noteModifierLike_sequence
  */
type ModelNoteModifierLikeSequence = java.lang.String

/** model.noteModifierLike_sequenceOptional
  */
type ModelNoteModifierLikeSequenceOptional = java.lang.String

/** model.noteModifierLike_sequenceOptionalRepeatable
  */
type ModelNoteModifierLikeSequenceOptionalRepeatable = java.lang.String

/** <body>
  *
  * Contains the whole of a single musical text, excluding any front or back matter.
  */
case class Body(
    /** <body> -> model.mdivLike -> mdiv -> <mdiv> (-> Mdiv)
      */
    elements: scala.List[Mdiv] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <body> -> att.common -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <body> -> att.common -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <body> -> att.common -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <body> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.
      * 
      * <body> -> att.metadataPointing -> att.metadataPointing.attribute.decls -> @decls
      */
    `@decls`: scala.Option[java.lang.String] = scala.None
)

/** <layer>
  *
  * An independent stream of events on a staff.
  */
case class Layer(
    /** <layer> -> model.layerPart -> model.eventLike -> note -> <note> (-> Note)
      */
    elements: scala.List[Note] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <layer> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <layer> -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.
      * 
      * <layer> -> att.metadataPointing -> att.metadataPointing.attribute.decls -> @decls
      */
    `@decls`: scala.Option[java.lang.String] = scala.None,
    /** Provides a numeric designation that indicates an element’s position in a sequence of similar elements. Its value must be a non-negative integer.
      * 
      * <layer> -> att.nInteger -> att.nInteger.attribute.n -> @n
      */
    `@n`: scala.Option[java.lang.String] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <layer> -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <layer> -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** 
      * 
      * <layer> -> att.layer.log -> att.cue -> att.cue.attribute.cue -> @cue
      */
    `@cue`: scala.Option[DataBOOLEAN] = scala.None,
    /** (meter conformance) Indicates the relationship between the content of a staff or layer and the prevailing meter.
      * 
      * <layer> -> att.layer.log -> att.meterConformance -> att.meterConformance.attribute.metcon -> @metcon
      */
    `@metcon`: scala.Option[java.lang.String] = scala.None,
    /** Provides a mechanism for linking the layer to a layerDef element.
      * 
      * <layer> -> att.layer.log -> att.layer.log.attribute.def -> @def
      */
    `@def`: scala.Option[DataURI] = scala.None
)

/** <mdiv>
  *
  * (musical division) Contains a subdivision of the body of a musical text.
  */
case class Mdiv(
    /** <mdiv> -> model.mdivLike -> mdiv -> <mdiv> (-> Mdiv)
      * <mdiv> -> model.scoreLike -> score -> <score> (-> Score)
      */
    elements: scala.List[Mdiv | Score] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <mdiv> -> att.common -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <mdiv> -> att.common -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <mdiv> -> att.common -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <mdiv> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.
      * 
      * <mdiv> -> att.metadataPointing -> att.metadataPointing.attribute.decls -> @decls
      */
    `@decls`: scala.Option[java.lang.String] = scala.None
)

/** <mei>
  *
  * Contains a single MEI-conformant document, consisting of an MEI header and a musical text, either in isolation or as part of an meiCorpus element.
  */
case class Mei(
    /** <mei> -> meiHead -> <meiHead> (-> MeiHead)
      * <mei> -> music -> <music> (-> Music)
      */
    elements: scala.List[MeiHead | Music] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <mei> -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Specifies a generic MEI version label.
      * 
      * <mei> -> att.meiVersion -> att.meiVersion.attribute.meiversion -> @meiversion
      */
    `@meiversion`: scala.Option[java.lang.String] = scala.None
)

/** <music>
  *
  * Contains a single musical text of any kind, whether unitary or composite, for example, an etude, opera, song cycle, symphony, or anthology of piano solos.
  */
case class Music(
    /** <music> -> macro.musicPart -> body -> <body> (-> Body)
      */
    elements: scala.List[Body] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <music> -> att.common -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <music> -> att.common -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <music> -> att.common -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <music> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Specifies a generic MEI version label.
      * 
      * <music> -> att.meiVersion -> att.meiVersion.attribute.meiversion -> @meiversion
      */
    `@meiversion`: scala.Option[java.lang.String] = scala.None,
    /** Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.
      * 
      * <music> -> att.metadataPointing -> att.metadataPointing.attribute.decls -> @decls
      */
    `@decls`: scala.Option[java.lang.String] = scala.None
)

/** <note>
  *
  * A single pitched event.
  */
case class Note(
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <note> -> att.common -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <note> -> att.common -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <note> -> att.common -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <note> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Records the number of augmentation dots required by a written dotted duration.
      * 
      * <note> -> att.note.log -> att.augmentDots -> att.augmentDots.attribute.dots -> @dots
      */
    `@dots`: scala.Option[DataAUGMENTDOT] = scala.None,
    /** Indicates this feature is 'colored'; that is, it is a participant in a change in rhythmic values. In mensural notation, coloration is indicated by colored notes (red, black, etc.) where void notes would otherwise occur. In CMN, coloration is indicated by an inverse color; that is, the note head is void when it would otherwise be filled and vice versa.
      * 
      * <note> -> att.note.log -> att.coloration -> att.coloration.attribute.colored -> @colored
      */
    `@colored`: scala.Option[DataBOOLEAN] = scala.None,
    /** 
      * 
      * <note> -> att.note.log -> att.cue -> att.cue.attribute.cue -> @cue
      */
    `@cue`: scala.Option[DataBOOLEAN] = scala.None,
    /** (duration) Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
      * 
      * <note> -> att.note.log -> att.duration.log -> att.duration.log.attribute.dur -> @dur
      */
    `@dur`: scala.Option[DataDURATION] = scala.None,
    /** Identifies the layer to which a feature applies.
      * 
      * <note> -> att.note.log -> att.event -> att.layerIdent -> att.layerIdent.attribute.layer -> @layer
      */
    `@layer`: scala.Option[java.lang.String] = scala.None,
    /** Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
      * 
      * <note> -> att.note.log -> att.event -> att.staffIdent -> att.staffIdent.attribute.staff -> @staff
      */
    `@staff`: scala.Option[java.lang.String] = scala.None,
    /** (time stamp) Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
      * 
      * <note> -> att.note.log -> att.event -> att.timestamp.log -> att.timestamp.log.attribute.tstamp -> @tstamp
      */
    `@tstamp`: scala.Option[DataBEAT] = scala.None,
    /** (pitch name) Contains a written pitch name.
      * 
      * <note> -> att.note.log -> att.pitched -> att.pitch -> att.pitch.attribute.pname -> @pname
      */
    `@pname`: scala.Option[DataPITCHNAME] = scala.None,
    /** (octave) Captures written octave information.
      * 
      * <note> -> att.note.log -> att.pitched -> att.octave -> att.octave.attribute.oct -> @oct
      */
    `@oct`: scala.Option[DataOCTAVE] = scala.None
)

/** <score>
  *
  * Full score view of the musical content.
  */
case class Score(
    /** <score> -> model.scorePart -> model.sectionLike -> section -> <section> (-> Section)
      */
    elements: scala.List[Section] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <score> -> att.common -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <score> -> att.common -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <score> -> att.common -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <score> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.
      * 
      * <score> -> att.metadataPointing -> att.metadataPointing.attribute.decls -> @decls
      */
    `@decls`: scala.Option[java.lang.String] = scala.None
)

/** <section>
  *
  * Segment of music data.
  */
case class Section(
    /** <section> -> model.sectionPart -> model.sectionLike -> section -> <section> (-> Section)
      * <section> -> model.sectionPart -> model.sectionPart.mensuralAndNeumes -> model.staffLike -> staff -> <staff> (-> Staff)
      */
    elements: scala.List[Section | Staff] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <section> -> att.common -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <section> -> att.common -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <section> -> att.common -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <section> -> att.common -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.
      * 
      * <section> -> att.metadataPointing -> att.metadataPointing.attribute.decls -> @decls
      */
    `@decls`: scala.Option[java.lang.String] = scala.None,
    /** Defines whether a link occurs automatically or must be requested by the user.
      * 
      * <section> -> att.pointing -> att.pointing.attribute.xlinkactuate -> @xlink:actuate
      */
    `@xlink:actuate`: scala.Option[java.lang.String] = scala.None,
    /** Characterization of the relationship between resources. The value of the role attribute must be a URI.
      * 
      * <section> -> att.pointing -> att.pointing.attribute.xlinkrole -> @xlink:role
      */
    `@xlink:role`: scala.Option[DataURI] = scala.None,
    /** Defines how a remote resource is rendered.
      * 
      * <section> -> att.pointing -> att.pointing.attribute.xlinkshow -> @xlink:show
      */
    `@xlink:show`: scala.Option[java.lang.String] = scala.None,
    /** Identifies passive participants in a relationship; that is, the entities pointed "to".
      * 
      * <section> -> att.pointing -> att.pointing.attribute.target -> @target
      */
    `@target`: scala.Option[java.lang.String] = scala.None,
    /** Characterization of target resource(s) using any convenient classification scheme or typology.
      * 
      * <section> -> att.pointing -> att.pointing.attribute.targettype -> @targettype
      */
    `@targettype`: scala.Option[java.lang.String] = scala.None,
    /** Specifies the intended meaning when a participant in a relationship is itself a pointer.
      * 
      * <section> -> att.targetEval -> att.targetEval.attribute.evaluate -> @evaluate
      */
    `@evaluate`: scala.Option[java.lang.String] = scala.None
)

/** <staff>
  *
  * A group of equidistant horizontal lines on which notes are placed in order to represent pitch or a grouping element for individual 'strands' of notes, rests, etc. that may or may not actually be rendered on staff lines; that is, both diastematic and non-diastematic signs.
  */
case class Staff(
    /** <staff> -> model.staffPart -> model.layerLike -> layer -> <layer> (-> Layer)
      */
    elements: scala.List[Layer] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <staff> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <staff> -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.
      * 
      * <staff> -> att.metadataPointing -> att.metadataPointing.attribute.decls -> @decls
      */
    `@decls`: scala.Option[java.lang.String] = scala.None,
    /** Provides a numeric designation that indicates an element’s position in a sequence of similar elements. Its value must be a non-negative integer.
      * 
      * <staff> -> att.nInteger -> att.nInteger.attribute.n -> @n
      */
    `@n`: scala.Option[java.lang.String] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <staff> -> att.typed -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * 
      * <staff> -> att.typed -> att.typed.type -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None,
    /** (meter conformance) Indicates the relationship between the content of a staff or layer and the prevailing meter.
      * 
      * <staff> -> att.staff.log -> att.meterConformance -> att.meterConformance.attribute.metcon -> @metcon
      */
    `@metcon`: scala.Option[java.lang.String] = scala.None,
    /** Provides a mechanism for linking the staff to a staffDef element.
      * 
      * <staff> -> att.staff.log -> att.staff.log.attribute.def -> @def
      */
    `@def`: scala.Option[DataURI] = scala.None
)

/** <title>
  *
  * Title of a bibliographic entity.
  */
case class Title(
    /** <title> -> text (-> java.lang.String)
      */
    elements: scala.List[java.lang.String] = scala.Nil,
    /** Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
      * 
      * <title> -> att.basic -> att.id -> att.id.xmlid -> @xml:id
      */
    `@xml:id`: scala.Option[java.lang.String] = scala.None,
    /** Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
      * 
      * <title> -> att.basic -> att.basic.xmlbase -> @xml:base
      */
    `@xml:base`: scala.Option[DataURI] = scala.None,
    /** Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
      * 
      * <title> -> att.classed -> att.classed.class -> @class
      */
    `@class`: scala.Option[java.lang.String] = scala.None,
    /** Indicates the bibliographic level of the title.
      * 
      * <title> -> @level
      */
    `@level`: scala.Option[java.lang.String] = scala.None,
    /** Characterizes the title in some sense, using any convenient classification scheme or typology that employs single-token labels.
      * Suggested values include: 1] main; 2] subordinate; 3] abbreviated; 4] alternative; 5] translated; 6] uniform; 7] desc
      * 
      * <title> -> @type
      */
    `@type`: scala.Option[java.lang.String] = scala.None
)

